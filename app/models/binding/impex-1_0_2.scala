// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package models.binding


/** 
               Space Physics Archive Search and Extract (SPASE).
               The outermost container or envelope for SPASE
               metadata. This indicates the start of the
               SPASE metadata.
            
*/
//case class Spase(Version: models.binding.EnumVersion,
//  ResourceEntity: Seq[scalaxb.DataRecord[Any]] = Nil,
//  lang: String)


/** 
               A tabular listing of events or observational
               notes, especially those that have utility
               in aiding a user in locating data. Catalogues
               include lists of events, files in a product,
               and data availability. A Catalog resource
               is a type of "data product" which is a set
               of data that is uniformly processed and formatted,
               from one or more instruments, typically spanning
               the full duration of the observations of the
               relevant instrument(s). A data product may
               consist of a collection of granules of successive
               time spans, but may be a single high-level
               entity.
            
*/
case class Catalog(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  AccessInformation: Seq[models.binding.AccessInformation] = Nil,
  ProviderResourceName: Option[String] = None,
  ProviderVersion: Option[String] = None,
  InstrumentID: Seq[String] = Nil,
  PhenomenonType: Seq[models.binding.EnumPhenomenonType] = Nil,
  TimeSpan: Option[models.binding.TimeSpan] = None,
  Caveats: Option[String] = None,
  Keyword: Seq[String] = Nil,
  InputResourceID: Seq[String] = Nil,
  Parameter: Seq[models.binding.Parameter] = Nil,
  Extension: Seq[models.binding.Extension] = Nil)


/** 
               Attributes of a resource which pertain to
               the provider of the resource and descriptive
               information about the resource.
            
*/
case class ResourceHeader(ResourceName: String,
  AlternateName: Seq[String] = Nil,
  ReleaseDate: javax.xml.datatype.XMLGregorianCalendar,
  ExpirationDate: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  Description: String,
  Acknowledgement: Option[String] = None,
  Contact: Seq[models.binding.Contact] = Nil,
  InformationURL: Seq[models.binding.InformationURL] = Nil,
  Association: Seq[models.binding.Association] = Nil,
  PriorID: Seq[String] = Nil)


/** 
               The person or organization who may be able
               to provide special assistance or serve as
               a channel for communication for additional
               information about a resource.
            
*/
case class Contact(PersonID: String,
  Role: Seq[models.binding.EnumRole] = Nil)


/** 
               Attributes of the method of acquiring additional
               information.
            
*/
case class InformationURL(Name: Option[String] = None,
  URL: String,
  Description: Option[String] = None,
  Language: Option[String] = None)


/** 
               Attributes of a relationship a resource has
               with another resource.
            
*/
case class Association(AssociationID: String,
  AssociationType: models.binding.EnumAssociationType,
  Note: Option[String] = None)


/** 
               Attributes of the resource which pertain to
               how to accessing the resource, availability
               and storage format.
            
*/
case class AccessInformation(RepositoryID: String,
  Availability: Option[models.binding.EnumAvailability] = None,
  AccessRights: Option[models.binding.EnumAccessRights] = None,
  AccessURL: Seq[models.binding.AccessURL] = Nil,
  Format: models.binding.EnumFormat,
  Encoding: Option[models.binding.EnumEncoding] = None,
  DataExtent: Option[models.binding.DataExtent] = None,
  Acknowledgement: Option[String] = None)


/** 
               Attributes of the method for accessing a resource
               including a URL, name and description.
            
*/
case class AccessURL(Name: Option[String] = None,
  URL: String,
  ProductKey: Seq[String] = Nil,
  Description: Option[String] = None,
  Language: Option[String] = None)


/** 
               The area of storage in a file system required
               to store the contents of a resource. The default
               units for data extent is bytes.
            
*/
case class DataExtent(Quantity: Double,
  Units: Option[String] = None,
  Per: Option[javax.xml.datatype.Duration] = None)


/** 
               The duration of an interval in time.
            
*/
case class TimeSpan(StartDate: javax.xml.datatype.XMLGregorianCalendar,
  StopDateEntity: scalaxb.DataRecord[Any],
  Note: Seq[String] = Nil)


/** 
               A container of information regarding a parameter
               whose values are part of the product. Every
               product contains or can be related to one
               or more parameters.
            
*/
case class Parameter(Name: String,
  Set: Seq[String] = Nil,
  ParameterKey: Option[String] = None,
  Description: Option[String] = None,
  Caveats: Option[String] = None,
  Cadence: Option[javax.xml.datatype.Duration] = None,
  Units: Option[String] = None,
  UnitsConversion: Option[String] = None,
  CoordinateSystem: Option[models.binding.CoordinateSystemType] = None,
  RenderingHints: Seq[models.binding.RenderingHints] = Nil,
  Structure: Option[models.binding.Structure] = None,
  ValidMin: Option[String] = None,
  ValidMax: Option[String] = None,
  FillValue: Option[String] = None,
  ParameterEntity: scalaxb.DataRecord[Any],
  Property: Seq[models.binding.Property] = Nil)


/** 
               The specification of the orientation of a
               set of (typically) orthogonal base axes.
            
*/
case class CoordinateSystemType(CoordinateRepresentation: models.binding.EnumCoordinateRepresentation,
  CoordinateSystemName: models.binding.EnumCoordinateSystemName)


/** 
               Attributes to aid in the rendering of parameter.
            
*/
case class RenderingHints(DisplayType: Option[models.binding.EnumDisplayType] = None,
  AxisLabel: Option[String] = None,
  RenderingAxis: Option[models.binding.EnumRenderingAxis] = None,
  Index: Option[Seq[BigInt]] = None,
  ValueFormat: Option[String] = None,
  ScaleMin: Option[Double] = None,
  ScaleMax: Option[Double] = None,
  ScaleType: Option[models.binding.EnumScaleType] = None)


/** 
               The organization and relationship of individual
               values within a quantity.
            
*/
case class Structure(Size: Seq[BigInt],
  Description: Option[String] = None,
  Element: Seq[models.binding.Element] = Nil)


/** 
               A component or individual unit of a multiple
               value quantity such as an array or vector.
            
*/
case class Element(Name: String,
  Qualifier: Seq[models.binding.EnumQualifier] = Nil,
  Index: Seq[BigInt],
  ParameterKey: Option[String] = None,
  Units: Option[String] = None,
  UnitsConversion: Option[String] = None,
  ValidMin: Option[String] = None,
  ValidMax: Option[String] = None,
  FillValue: Option[String] = None,
  RenderingHints: Option[models.binding.RenderingHints] = None)


/** 
               The space around a radiating body within which
               its electromagnetic attributes can exert force
               on another similar body that is not in direct
               contact.
            
*/
case class FieldType(Qualifier: Seq[models.binding.EnumQualifier] = Nil,
  FieldQuantity: models.binding.EnumFieldQuantity,
  FrequencyRange: Option[models.binding.FrequencyRange] = None)


/** 
               The range of possible values for the observed
               frequency.
            
*/
case class FrequencyRange(SpectralRange: Option[models.binding.EnumSpectralRange] = None,
  Low: Double,
  High: Double,
  Units: String,
  Bin: Seq[models.binding.Bin] = Nil)


/** 
               A grouping of observations according to a
               band or window of a common attribute.
            
*/
case class Bin(BandName: Option[String] = None,
  Low: Double,
  High: Double)


/** 
               The minimum and maximum energy values of the
               particles represented by a given "physical
               parameter" description.
            
*/
case class EnergyRange(Low: Double,
  High: Double,
  Units: String,
  Bin: Seq[models.binding.Bin] = Nil)


/** 
               The range of possible azimuthal angles for
               a group of energy observations. Default units
               are degrees.
            
*/
case class AzimuthalAngleRange(Low: Double,
  High: Double,
  Units: String,
  Bin: Seq[models.binding.Bin] = Nil)


/** 
               The range of possible polar angles for a group
               of energy observations. Defaults units are
               degrees.
            
*/
case class PolarAngleRange(Low: Double,
  High: Double,
  Units: String,
  Bin: Seq[models.binding.Bin] = Nil)


/** 
               Periodic or quasi-periodic (AC) variations
               of physical quantities in time and space,
               capable of propagating or being trapped within
               particular regimes.
            
*/
case class Wave(WaveType: models.binding.EnumWaveType,
  Qualifier: Seq[models.binding.EnumQualifier] = Nil,
  WaveQuantity: models.binding.EnumWaveQuantity,
  EnergyRange: Option[models.binding.EnergyRange] = None,
  FrequencyRange: Option[models.binding.FrequencyRange] = None,
  WavelengthRange: Option[models.binding.WavelengthRange] = None)


/** 
               The range of possible values for the observed
               wavelength.
            
*/
case class WavelengthRange(SpectralRange: Option[models.binding.EnumSpectralRange] = None,
  Low: Double,
  High: Double,
  Units: String,
  Bin: Seq[models.binding.Bin] = Nil)


/** 
               A parameter derived from more than one of
               the type of parameter. For example, plasma
               beta, the ratio of plasma particle energy
               density to the energy density of the magnetic
               field permeating the plasma, is "mixed."
            
*/
case class Mixed(MixedQuantity: models.binding.EnumMixedQuantity,
  ParticleType: Seq[models.binding.EnumParticleType] = Nil,
  Qualifier: Seq[models.binding.EnumQualifier] = Nil)


/** 
               Information useful in understanding the context
               of an observation, typically observed or measured
               coincidentally with a physical observation.
            
*/
case class Support(Qualifier: Seq[models.binding.EnumQualifier] = Nil,
  SupportQuantity: models.binding.EnumSupportQuantity)


/** 
               A container of other metadata which is not
               part of the SPASE data model. The contents
               of this element are defined by individual
               usage. The organization and content are constrained
               by the implementation. For example, in an
               XML representation of the SPASE metadata the
               content must conform to the XML specifications.
            
*/
case class Extension(any: Option[scalaxb.DataRecord[Any]] = None)


/** 
               A graphical representation of data wherein
               the underlying numeric values are not (readily)
               accessible for analysis.. Examples are line
               plots and spectrograms. A Display Data resource
               is a type of "data product" which is a set
               of data that is uniformly processed and formatted,
               from one or more instruments, typically spanning
               the full duration of the observations of the
               relevant instrument(s). A data product may
               consist of a collection of granules of successive
               time spans, but may be a single high-level
               entity.
            
*/
case class DisplayData(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  AccessInformation: Seq[models.binding.AccessInformation] = Nil,
  ProcessingLevel: Option[models.binding.EnumProcessingLevel] = None,
  ProviderResourceName: Option[String] = None,
  ProviderProcessingLevel: Option[String] = None,
  ProviderVersion: Option[String] = None,
  InstrumentID: Seq[String] = Nil,
  MeasurementType: Seq[models.binding.EnumMeasurementType] = Nil,
  TemporalDescription: Option[models.binding.TemporalDescription] = None,
  SpectralRange: Seq[models.binding.EnumSpectralRange] = Nil,
  DisplayCadence: Option[javax.xml.datatype.Duration] = None,
  ObservedRegion: Seq[models.binding.EnumRegion] = Nil,
  Caveats: Option[String] = None,
  Keyword: Seq[String] = Nil,
  InputResourceID: Seq[String] = Nil,
  Parameter: Seq[models.binding.Parameter] = Nil,
  Extension: Seq[models.binding.Extension] = Nil)


/** 
               A characterization of the time over which
               the measurement was taken.
            
*/
case class TemporalDescription(TimeSpan: models.binding.TimeSpan,
  Cadence: Option[javax.xml.datatype.Duration] = None,
  Exposure: Option[javax.xml.datatype.Duration] = None) extends NumericalOutputOption with DisplayOutputOption


/** 
               Data stored as numerical values in a specified
               format. A Numerical Data resource is a type
               of "data product" which is a set of data that
               is uniformly processed and formatted, from
               one or more instruments, typically spanning
               the full duration of the observations of the
               relevant instrument(s). A data product may
               consist of a collection of granules of successive
               time spans, but may be a single high-level
               entity.
            
*/
case class NumericalData(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  AccessInformation: Seq[models.binding.AccessInformation] = Nil,
  ProcessingLevel: Option[models.binding.EnumProcessingLevel] = None,
  ProviderResourceName: Option[String] = None,
  ProviderProcessingLevel: Option[String] = None,
  ProviderVersion: Option[String] = None,
  InstrumentID: Seq[String] = Nil,
  MeasurementType: Seq[models.binding.EnumMeasurementType] = Nil,
  TemporalDescription: Option[models.binding.TemporalDescription] = None,
  SpectralRange: Seq[models.binding.EnumSpectralRange] = Nil,
  ObservedRegion: Seq[models.binding.EnumRegion] = Nil,
  Caveats: Option[String] = None,
  Keyword: Seq[String] = Nil,
  InputResourceID: Seq[String] = Nil,
  Parameter: Seq[models.binding.Parameter] = Nil,
  Extension: Seq[models.binding.Extension] = Nil)


/** 
               A set of information designed and presented
               as an individual entity. A document may contain
               plain or formatted text, in-line graphics,
               sound, other multimedia data, or hypermedia
               references. A Document resource is intended
               for use on digital objects that have no other
               identifier (e.g., DOI or ISBN). 
            
*/
case class Document(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  AccessInformation: Seq[models.binding.AccessInformation] = Nil,
  Keyword: Seq[String] = Nil,
  DocumentType: models.binding.EnumDocumentType,
  MIMEType: Boolean,
  InputResourceID: Seq[String] = Nil)


/** 
               The location and attributes of an object.
            
*/
case class Source(SourceType: models.binding.EnumSourceType,
  URL: String,
  MirrorURL: Seq[String] = Nil,
  Checksum: Option[models.binding.Checksum] = None,
  DataExtent: Option[models.binding.DataExtent] = None)


/** 
               A computed value that is dependent upon the
               contents of a digital data object. Primarily
               used to check whether errors or alterations
               have occurred during the transmission or storage
               of a data object.
            
*/
case class Checksum(HashValue: String,
  HashFunction: models.binding.EnumHashFunction)


/** 
               A device that makes measurements used to characterize
               a physical phenomenon, or a family of like
               devices.
            
*/
case class Instrument(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  InstrumentType: Seq[models.binding.EnumInstrumentType] = Nil,
  InvestigationName: Seq[String] = Nil,
  OperatingSpan: Option[models.binding.OperatingSpan] = None,
  ObservatoryID: String,
  Caveats: Option[String] = None,
  Extension: Seq[models.binding.Extension] = Nil)


/** 
               The interval in time from the first point
               at which an instrument or spacecraft was producing
               and sending data until the last such time,
               ignoring possible gaps.
            
*/
case class OperatingSpan(StartDate: javax.xml.datatype.XMLGregorianCalendar,
  StopDate: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  Note: Seq[String] = Nil)


/** 
               The host (spacecraft, network, facility) for
               instruments making observations, or a family
               of closely related hosts.
            
*/
case class Observatory(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  ObservatoryGroupID: Seq[String] = Nil,
  Location: models.binding.Location,
  OperatingSpan: Option[models.binding.OperatingSpan] = None,
  Extension: Seq[models.binding.Extension] = Nil)


/** 
               A position in space definable by a regional
               referencing system and geographic coordinates.
            
*/
case class Location(ObservatoryRegion: Seq[models.binding.EnumRegion] = Nil,
  CoordinateSystemName: Option[models.binding.EnumCoordinateSystemName] = None,
  Latitude: Option[Double] = None,
  Longitude: Option[Double] = None,
  Elevation: Option[Double] = None)


/** 
               An individual human being.
            
*/
case class Person(ResourceID: String,
  ReleaseDate: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  PersonName: Option[String] = None,
  OrganizationName: String,
  Address: Option[String] = None,
  Email: Seq[String] = Nil,
  PhoneNumber: Seq[String] = Nil,
  FaxNumber: Option[String] = None,
  Note: Option[String] = None,
  Extension: Seq[models.binding.Extension] = Nil)


/** 
               A location or facility where resources are
               cataloged.
            
*/
case class Registry(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  AccessURL: models.binding.AccessURL,
  Extension: Seq[models.binding.Extension] = Nil)


/** 
               A location or facility where resources are
               stored.
            
*/
case class Repository(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  AccessURL: models.binding.AccessURL,
  Extension: Seq[models.binding.Extension] = Nil)


/** 
               A location or facility that can perform a
               well defined task.
            
*/
case class Service(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  AccessURL: models.binding.AccessURL,
  Extension: Seq[models.binding.Extension] = Nil)


/** 
               Information which is explanatory or descriptive
               which is associated with another resource.
            
*/
case class Annotation(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  ImageURL: Option[String] = None,
  AnnotationType: models.binding.EnumAnnotationType,
  PhenomenonType: Option[models.binding.EnumPhenomenonType] = None,
  ClassificationMethod: Option[models.binding.EnumClassificationMethod] = None,
  ConfidenceRating: Option[models.binding.EnumConfidenceRating] = None,
  TimeSpan: Seq[models.binding.TimeSpan] = Nil,
  ObservationExtent: Seq[models.binding.ObservationExtent] = Nil,
  Extension: Seq[models.binding.Extension] = Nil)


/** 
               The spatial area encompassed by an observation.
            
*/
case class ObservationExtent(ObservedRegion: Option[models.binding.EnumRegion] = None,
  StartLocation: String,
  StopLocation: String,
  Note: Seq[String] = Nil)

trait EnumVersion

object EnumVersion {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumVersion = value match {
    case "2.2.2" => Number2u462u462

  }
}

case object Number2u462u462 extends EnumVersion { override def toString = "2.2.2" }

trait EnumAccessRights

object EnumAccessRights {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumAccessRights = value match {
    case "Open" => Open
    case "Restricted" => Restricted

  }
}

case object Open extends EnumAccessRights { override def toString = "Open" }
case object Restricted extends EnumAccessRights { override def toString = "Restricted" }

trait EnumAnnotationType

object EnumAnnotationType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumAnnotationType = value match {
    case "Anomaly" => Anomaly
    case "Event" => Event
    case "Feature" => Feature

  }
}

case object Anomaly extends EnumAnnotationType { override def toString = "Anomaly" }
case object Event extends EnumAnnotationType { override def toString = "Event" }
case object Feature extends EnumAnnotationType { override def toString = "Feature" }

trait EnumAssociationType

object EnumAssociationType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumAssociationType = value match {
    case "ChildEventOf" => ChildEventOf
    case "DerivedFrom" => DerivedFrom
    case "ObservedBy" => ObservedBy
    case "Other" => OtherValue
    case "PartOf" => PartOf
    case "RevisionOf" => RevisionOf

  }
}

case object ChildEventOf extends EnumAssociationType { override def toString = "ChildEventOf" }
case object DerivedFrom extends EnumAssociationType { override def toString = "DerivedFrom" }
case object ObservedBy extends EnumAssociationType { override def toString = "ObservedBy" }
case object OtherValue extends EnumAssociationType { override def toString = "Other" }
case object PartOf extends EnumAssociationType { override def toString = "PartOf" }
case object RevisionOf extends EnumAssociationType { override def toString = "RevisionOf" }

trait EnumAvailability

object EnumAvailability {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumAvailability = value match {
    case "Offline" => Offline
    case "Online" => Online

  }
}

case object Offline extends EnumAvailability { override def toString = "Offline" }
case object Online extends EnumAvailability { override def toString = "Online" }

trait EnumClassificationMethod

object EnumClassificationMethod {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumClassificationMethod = value match {
    case "Automatic" => Automatic
    case "Inferred" => Inferred
    case "Inspection" => Inspection

  }
}

case object Automatic extends EnumClassificationMethod { override def toString = "Automatic" }
case object Inferred extends EnumClassificationMethod { override def toString = "Inferred" }
case object Inspection extends EnumClassificationMethod { override def toString = "Inspection" }

trait EnumComponent

object EnumComponent {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumComponent = value match {
    case "I" => I
    case "J" => J
    case "K" => K

  }
}

case object I extends EnumComponent { override def toString = "I" }
case object J extends EnumComponent { override def toString = "J" }
case object K extends EnumComponent { override def toString = "K" }

trait EnumConfidenceRating

object EnumConfidenceRating {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumConfidenceRating = value match {
    case "Probable" => Probable
    case "Strong" => Strong
    case "Unlikely" => Unlikely
    case "Weak" => Weak

  }
}

case object Probable extends EnumConfidenceRating { override def toString = "Probable" }
case object Strong extends EnumConfidenceRating { override def toString = "Strong" }
case object Unlikely extends EnumConfidenceRating { override def toString = "Unlikely" }
case object Weak extends EnumConfidenceRating { override def toString = "Weak" }

trait EnumCoordinateRepresentation

object EnumCoordinateRepresentation {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumCoordinateRepresentation = value match {
    case "Cartesian" => Cartesian
    case "Cylindrical" => Cylindrical
    case "Spherical" => Spherical

  }
}

case object Cartesian extends EnumCoordinateRepresentation { override def toString = "Cartesian" }
case object Cylindrical extends EnumCoordinateRepresentation { override def toString = "Cylindrical" }
case object Spherical extends EnumCoordinateRepresentation { override def toString = "Spherical" }

trait EnumCoordinateSystemName

object EnumCoordinateSystemName {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumCoordinateSystemName = value match {
    case "CGM" => CGM
    case "Carrington" => Carrington
    case "CSO" => CSO
    case "DM" => DM
    case "GEI" => GEI
    case "GEO" => GEO
    case "GPHIO" => GPHIO
    case "GSE" => GSE
    case "GSEQ" => GSEQ
    case "GSM" => GSM
    case "HAE" => HAE
    case "HCC" => HCC
    case "HCI" => HCI
    case "HCR" => HCR
    case "HEE" => HEE
    case "HEEQ" => HEEQ
    case "HG" => HG
    case "HGI" => HGI
    case "HPC" => HPC
    case "HPR" => HPR
    case "HSM" => HSM
    case "J2000" => J2000
    case "JSM" => JSM
    case "JSO" => JSO
    case "KSM" => KSM
    case "KSO" => KSO
    case "LGM" => LGM
    case "MAG" => MAG
    case "MFA" => MFA
    case "MSO" => MSO
    case "RTN" => RTN
    case "SC" => SC
    case "SE" => SE
    case "SM" => SM
    case "SR" => SR
    case "SR2" => SR2
    case "SSE" => SSE
    case "SSE_L" => SSE_L
    case "SpacecraftOrbitPlane" => SpacecraftOrbitPlane
    case "TIIS" => TIIS
    case "VSO" => VSO
    case "WGS84" => WGS84

  }
}

case object CGM extends EnumCoordinateSystemName { override def toString = "CGM" }
case object Carrington extends EnumCoordinateSystemName { override def toString = "Carrington" }
case object CSO extends EnumCoordinateSystemName { override def toString = "CSO" }
case object DM extends EnumCoordinateSystemName { override def toString = "DM" }
case object GEI extends EnumCoordinateSystemName { override def toString = "GEI" }
case object GEO extends EnumCoordinateSystemName { override def toString = "GEO" }
case object GPHIO extends EnumCoordinateSystemName { override def toString = "GPHIO" }
case object GSE extends EnumCoordinateSystemName { override def toString = "GSE" }
case object GSEQ extends EnumCoordinateSystemName { override def toString = "GSEQ" }
case object GSM extends EnumCoordinateSystemName { override def toString = "GSM" }
case object HAE extends EnumCoordinateSystemName { override def toString = "HAE" }
case object HCC extends EnumCoordinateSystemName { override def toString = "HCC" }
case object HCI extends EnumCoordinateSystemName { override def toString = "HCI" }
case object HCR extends EnumCoordinateSystemName { override def toString = "HCR" }
case object HEE extends EnumCoordinateSystemName { override def toString = "HEE" }
case object HEEQ extends EnumCoordinateSystemName { override def toString = "HEEQ" }
case object HG extends EnumCoordinateSystemName { override def toString = "HG" }
case object HGI extends EnumCoordinateSystemName { override def toString = "HGI" }
case object HPC extends EnumCoordinateSystemName { override def toString = "HPC" }
case object HPR extends EnumCoordinateSystemName { override def toString = "HPR" }
case object HSM extends EnumCoordinateSystemName { override def toString = "HSM" }
case object J2000 extends EnumCoordinateSystemName { override def toString = "J2000" }
case object JSM extends EnumCoordinateSystemName { override def toString = "JSM" }
case object JSO extends EnumCoordinateSystemName { override def toString = "JSO" }
case object KSM extends EnumCoordinateSystemName { override def toString = "KSM" }
case object KSO extends EnumCoordinateSystemName { override def toString = "KSO" }
case object LGM extends EnumCoordinateSystemName { override def toString = "LGM" }
case object MAG extends EnumCoordinateSystemName { override def toString = "MAG" }
case object MFA extends EnumCoordinateSystemName { override def toString = "MFA" }
case object MSO extends EnumCoordinateSystemName { override def toString = "MSO" }
case object RTN extends EnumCoordinateSystemName { override def toString = "RTN" }
case object SC extends EnumCoordinateSystemName { override def toString = "SC" }
case object SE extends EnumCoordinateSystemName { override def toString = "SE" }
case object SM extends EnumCoordinateSystemName { override def toString = "SM" }
case object SR extends EnumCoordinateSystemName { override def toString = "SR" }
case object SR2 extends EnumCoordinateSystemName { override def toString = "SR2" }
case object SSE extends EnumCoordinateSystemName { override def toString = "SSE" }
case object SSE_L extends EnumCoordinateSystemName { override def toString = "SSE_L" }
case object SpacecraftOrbitPlane extends EnumCoordinateSystemName { override def toString = "SpacecraftOrbitPlane" }
case object TIIS extends EnumCoordinateSystemName { override def toString = "TIIS" }
case object VSO extends EnumCoordinateSystemName { override def toString = "VSO" }
case object WGS84 extends EnumCoordinateSystemName { override def toString = "WGS84" }

trait EnumDirectionAngle

object EnumDirectionAngle {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumDirectionAngle = value match {
    case "AzimuthAngle" => AzimuthAngle
    case "ElevationAngle" => ElevationAngle
    case "PolarAngle" => PolarAngle

  }
}

case object AzimuthAngle extends EnumDirectionAngle { override def toString = "AzimuthAngle" }
case object ElevationAngle extends EnumDirectionAngle { override def toString = "ElevationAngle" }
case object PolarAngle extends EnumDirectionAngle { override def toString = "PolarAngle" }

trait EnumDisplayType

object EnumDisplayType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumDisplayType = value match {
    case "Image" => Image
    case "Plasmagram" => Plasmagram
    case "Spectrogram" => Spectrogram
    case "StackPlot" => StackPlot
    case "TimeSeries" => TimeSeries
    case "WaveForm" => WaveForm

  }
}

case object Image extends EnumDisplayType { override def toString = "Image" }
case object Plasmagram extends EnumDisplayType { override def toString = "Plasmagram" }
case object Spectrogram extends EnumDisplayType { override def toString = "Spectrogram" }
case object StackPlot extends EnumDisplayType { override def toString = "StackPlot" }
case object TimeSeries extends EnumDisplayType { override def toString = "TimeSeries" }
case object WaveForm extends EnumDisplayType { override def toString = "WaveForm" }

trait EnumDocumentType

object EnumDocumentType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumDocumentType = value match {
    case "Other" => Other
    case "Poster" => Poster
    case "Presentation" => Presentation
    case "Report" => Report
    case "Specification" => Specification
    case "TechnicalNote" => TechnicalNote
    case "WhitePaper" => WhitePaper

  }
}

case object Other extends EnumDocumentType { override def toString = "Other" }
case object Poster extends EnumDocumentType { override def toString = "Poster" }
case object Presentation extends EnumDocumentType { override def toString = "Presentation" }
case object Report extends EnumDocumentType { override def toString = "Report" }
case object Specification extends EnumDocumentType { override def toString = "Specification" }
case object TechnicalNote extends EnumDocumentType { override def toString = "TechnicalNote" }
case object WhitePaper extends EnumDocumentType { override def toString = "WhitePaper" }

trait EnumEarth

object EnumEarth {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumEarth = value match {
    case "Magnetosheath" => Magnetosheath
    case "Magnetosphere" => Magnetosphere
    case "Magnetosphere.Magnetotail" => Magnetosphereu46Magnetotail
    case "Magnetosphere.Main" => Magnetosphereu46Main
    case "Magnetosphere.Polar" => Magnetosphereu46Polar
    case "Magnetosphere.RadiationBelt" => Magnetosphereu46RadiationBelt
    case "NearSurface" => NearSurface
    case "NearSurface.Atmosphere" => NearSurfaceu46Atmosphere
    case "NearSurface.AuroralRegion" => NearSurfaceu46AuroralRegion
    case "NearSurface.EquatorialRegion" => NearSurfaceu46EquatorialRegion
    case "NearSurface.Ionosphere" => NearSurfaceu46Ionosphere
    case "NearSurface.Ionosphere.DRegion" => NearSurfaceu46Ionosphereu46DRegion
    case "NearSurface.Ionosphere.ERegion" => NearSurfaceu46Ionosphereu46ERegion
    case "NearSurface.Ionosphere.FRegion" => NearSurfaceu46Ionosphereu46FRegion
    case "NearSurface.Ionosphere.Topside" => NearSurfaceu46Ionosphereu46Topside
    case "NearSurface.Mesosphere" => NearSurfaceu46Mesosphere
    case "NearSurface.Plasmasphere" => NearSurfaceu46Plasmasphere
    case "NearSurface.PolarCap" => NearSurfaceu46PolarCap
    case "NearSurface.SouthAtlanticAnomalyRegion" => NearSurfaceu46SouthAtlanticAnomalyRegion
    case "NearSurface.Stratosphere" => NearSurfaceu46Stratosphere
    case "NearSurface.Thermosphere" => NearSurfaceu46Thermosphere
    case "NearSurface.Troposphere" => NearSurfaceu46Troposphere
    case "Surface" => Surface

  }
}

case object Magnetosheath extends EnumEarth { override def toString = "Magnetosheath" }
case object Magnetosphere extends EnumEarth { override def toString = "Magnetosphere" }
case object Magnetosphereu46Magnetotail extends EnumEarth { override def toString = "Magnetosphere.Magnetotail" }
case object Magnetosphereu46Main extends EnumEarth { override def toString = "Magnetosphere.Main" }
case object Magnetosphereu46Polar extends EnumEarth { override def toString = "Magnetosphere.Polar" }
case object Magnetosphereu46RadiationBelt extends EnumEarth { override def toString = "Magnetosphere.RadiationBelt" }
case object NearSurface extends EnumEarth { override def toString = "NearSurface" }
case object NearSurfaceu46Atmosphere extends EnumEarth { override def toString = "NearSurface.Atmosphere" }
case object NearSurfaceu46AuroralRegion extends EnumEarth { override def toString = "NearSurface.AuroralRegion" }
case object NearSurfaceu46EquatorialRegion extends EnumEarth { override def toString = "NearSurface.EquatorialRegion" }
case object NearSurfaceu46Ionosphere extends EnumEarth { override def toString = "NearSurface.Ionosphere" }
case object NearSurfaceu46Ionosphereu46DRegion extends EnumEarth { override def toString = "NearSurface.Ionosphere.DRegion" }
case object NearSurfaceu46Ionosphereu46ERegion extends EnumEarth { override def toString = "NearSurface.Ionosphere.ERegion" }
case object NearSurfaceu46Ionosphereu46FRegion extends EnumEarth { override def toString = "NearSurface.Ionosphere.FRegion" }
case object NearSurfaceu46Ionosphereu46Topside extends EnumEarth { override def toString = "NearSurface.Ionosphere.Topside" }
case object NearSurfaceu46Mesosphere extends EnumEarth { override def toString = "NearSurface.Mesosphere" }
case object NearSurfaceu46Plasmasphere extends EnumEarth { override def toString = "NearSurface.Plasmasphere" }
case object NearSurfaceu46PolarCap extends EnumEarth { override def toString = "NearSurface.PolarCap" }
case object NearSurfaceu46SouthAtlanticAnomalyRegion extends EnumEarth { override def toString = "NearSurface.SouthAtlanticAnomalyRegion" }
case object NearSurfaceu46Stratosphere extends EnumEarth { override def toString = "NearSurface.Stratosphere" }
case object NearSurfaceu46Thermosphere extends EnumEarth { override def toString = "NearSurface.Thermosphere" }
case object NearSurfaceu46Troposphere extends EnumEarth { override def toString = "NearSurface.Troposphere" }
case object Surface extends EnumEarth { override def toString = "Surface" }

trait EnumEncoding

object EnumEncoding {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumEncoding = value match {
    case "ASCII" => ASCIIValue
    case "BZIP2" => BZIP2
    case "Base64" => Base64Value
    case "GZIP" => GZIPValue
    case "None" => NoneTypeValue2
    case "S3_BUCKET" => S3_BUCKET
    case "TAR" => TAR
    case "Unicode" => UnicodeValue
    case "ZIP" => ZIP

  }
}

case object ASCIIValue extends EnumEncoding { override def toString = "ASCII" }
case object BZIP2 extends EnumEncoding { override def toString = "BZIP2" }
case object Base64Value extends EnumEncoding { override def toString = "Base64" }
case object GZIPValue extends EnumEncoding { override def toString = "GZIP" }
case object NoneTypeValue2 extends EnumEncoding { override def toString = "None" }
case object S3_BUCKET extends EnumEncoding { override def toString = "S3_BUCKET" }
case object TAR extends EnumEncoding { override def toString = "TAR" }
case object UnicodeValue extends EnumEncoding { override def toString = "Unicode" }
case object ZIP extends EnumEncoding { override def toString = "ZIP" }

trait EnumFieldQuantity

object EnumFieldQuantity {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumFieldQuantity = value match {
    case "Current" => CurrentValue
    case "Electric" => Electric
    case "Electromagnetic" => ElectromagneticValue
    case "Gyrofrequency" => Gyrofrequency
    case "Magnetic" => Magnetic
    case "PlasmaFrequency" => PlasmaFrequency
    case "Potential" => Potential
    case "PoyntingFlux" => PoyntingFlux

  }
}

case object CurrentValue extends EnumFieldQuantity { override def toString = "Current" }
case object Electric extends EnumFieldQuantity { override def toString = "Electric" }
case object ElectromagneticValue extends EnumFieldQuantity { override def toString = "Electromagnetic" }
case object Gyrofrequency extends EnumFieldQuantity { override def toString = "Gyrofrequency" }
case object Magnetic extends EnumFieldQuantity { override def toString = "Magnetic" }
case object PlasmaFrequency extends EnumFieldQuantity { override def toString = "PlasmaFrequency" }
case object Potential extends EnumFieldQuantity { override def toString = "Potential" }
case object PoyntingFlux extends EnumFieldQuantity { override def toString = "PoyntingFlux" }

trait EnumFormat

object EnumFormat {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumFormat = value match {
    case "AVI" => AVI
    case "Binary" => BinaryValue
    case "CDF" => CDF
    case "CEF" => CEF
    case "CEF1" => CEF1
    case "CEF2" => CEF2
    case "Excel" => Excel
    case "FITS" => FITSValue
    case "GIF" => GIF
    case "HDF" => HDF
    case "HDF4" => HDF4
    case "HDF5" => HDF5
    case "HTML" => HTML
    case "Hardcopy" => Hardcopy
    case "Hardcopy.Film" => Hardcopyu46Film
    case "Hardcopy.Microfiche" => Hardcopyu46Microfiche
    case "Hardcopy.Microfilm" => Hardcopyu46Microfilm
    case "Hardcopy.Photograph" => Hardcopyu46Photograph
    case "Hardcopy.PhotographicPlate" => Hardcopyu46PhotographicPlate
    case "Hardcopy.Print" => Hardcopyu46Print
    case "IDFS" => IDFS
    case "IDL" => IDL
    case "JPEG" => JPEG
    case "MATLAB_4" => MATLAB_4
    case "MATLAB_6" => MATLAB_6
    case "MATLAB_7" => MATLAB_7
    case "MPEG" => MPEG
    case "NCAR" => NCAR
    case "NetCDF" => NetCDF
    case "PDF" => PDF
    case "PNG" => PNG
    case "Postscript" => Postscript
    case "QuickTime" => QuickTime
    case "TIFF" => TIFF
    case "Text" => Text
    case "Text.ASCII" => Textu46ASCII
    case "Text.Unicode" => Textu46Unicode
    case "UDF" => UDF
    case "VOTable" => VOTableValue
    case "XML" => XML

  }
}

case object AVI extends EnumFormat { override def toString = "AVI" }
case object BinaryValue extends EnumFormat { override def toString = "Binary" }
case object CDF extends EnumFormat { override def toString = "CDF" }
case object CEF extends EnumFormat { override def toString = "CEF" }
case object CEF1 extends EnumFormat { override def toString = "CEF1" }
case object CEF2 extends EnumFormat { override def toString = "CEF2" }
case object Excel extends EnumFormat { override def toString = "Excel" }
case object FITSValue extends EnumFormat { override def toString = "FITS" }
case object GIF extends EnumFormat { override def toString = "GIF" }
case object HDF extends EnumFormat { override def toString = "HDF" }
case object HDF4 extends EnumFormat { override def toString = "HDF4" }
case object HDF5 extends EnumFormat { override def toString = "HDF5" }
case object HTML extends EnumFormat { override def toString = "HTML" }
case object Hardcopy extends EnumFormat { override def toString = "Hardcopy" }
case object Hardcopyu46Film extends EnumFormat { override def toString = "Hardcopy.Film" }
case object Hardcopyu46Microfiche extends EnumFormat { override def toString = "Hardcopy.Microfiche" }
case object Hardcopyu46Microfilm extends EnumFormat { override def toString = "Hardcopy.Microfilm" }
case object Hardcopyu46Photograph extends EnumFormat { override def toString = "Hardcopy.Photograph" }
case object Hardcopyu46PhotographicPlate extends EnumFormat { override def toString = "Hardcopy.PhotographicPlate" }
case object Hardcopyu46Print extends EnumFormat { override def toString = "Hardcopy.Print" }
case object IDFS extends EnumFormat { override def toString = "IDFS" }
case object IDL extends EnumFormat { override def toString = "IDL" }
case object JPEG extends EnumFormat { override def toString = "JPEG" }
case object MATLAB_4 extends EnumFormat { override def toString = "MATLAB_4" }
case object MATLAB_6 extends EnumFormat { override def toString = "MATLAB_6" }
case object MATLAB_7 extends EnumFormat { override def toString = "MATLAB_7" }
case object MPEG extends EnumFormat { override def toString = "MPEG" }
case object NCAR extends EnumFormat { override def toString = "NCAR" }
case object NetCDF extends EnumFormat { override def toString = "NetCDF" }
case object PDF extends EnumFormat { override def toString = "PDF" }
case object PNG extends EnumFormat { override def toString = "PNG" }
case object Postscript extends EnumFormat { override def toString = "Postscript" }
case object QuickTime extends EnumFormat { override def toString = "QuickTime" }
case object TIFF extends EnumFormat { override def toString = "TIFF" }
case object Text extends EnumFormat { override def toString = "Text" }
case object Textu46ASCII extends EnumFormat { override def toString = "Text.ASCII" }
case object Textu46Unicode extends EnumFormat { override def toString = "Text.Unicode" }
case object UDF extends EnumFormat { override def toString = "UDF" }
case object VOTableValue extends EnumFormat { override def toString = "VOTable" }
case object XML extends EnumFormat { override def toString = "XML" }

trait EnumHardcopy

object EnumHardcopy {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumHardcopy = value match {
    case "Film" => Film
    case "Microfiche" => Microfiche
    case "Microfilm" => Microfilm
    case "Photograph" => Photograph
    case "PhotographicPlate" => PhotographicPlate
    case "Print" => Print

  }
}

case object Film extends EnumHardcopy { override def toString = "Film" }
case object Microfiche extends EnumHardcopy { override def toString = "Microfiche" }
case object Microfilm extends EnumHardcopy { override def toString = "Microfilm" }
case object Photograph extends EnumHardcopy { override def toString = "Photograph" }
case object PhotographicPlate extends EnumHardcopy { override def toString = "PhotographicPlate" }
case object Print extends EnumHardcopy { override def toString = "Print" }

trait EnumHashFunction

object EnumHashFunction {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumHashFunction = value match {
    case "MD5" => MD5
    case "SHA1" => SHA1
    case "SHA256" => SHA256

  }
}

case object MD5 extends EnumHashFunction { override def toString = "MD5" }
case object SHA1 extends EnumHashFunction { override def toString = "SHA1" }
case object SHA256 extends EnumHashFunction { override def toString = "SHA256" }

trait EnumHeliosphere

object EnumHeliosphere {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumHeliosphere = value match {
    case "Heliosheath" => Heliosheath
    case "Inner" => Inner
    case "NearEarth" => NearEarth
    case "Outer" => Outer
    case "Remote1AU" => Remote1AU

  }
}

case object Heliosheath extends EnumHeliosphere { override def toString = "Heliosheath" }
case object Inner extends EnumHeliosphere { override def toString = "Inner" }
case object NearEarth extends EnumHeliosphere { override def toString = "NearEarth" }
case object Outer extends EnumHeliosphere { override def toString = "Outer" }
case object Remote1AU extends EnumHeliosphere { override def toString = "Remote1AU" }

trait EnumInstrumentType

object EnumInstrumentType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumInstrumentType = value match {
    case "Antenna" => Antenna
    case "Channeltron" => Channeltron
    case "Coronograph" => Coronograph
    case "DoubleSphere" => DoubleSphere
    case "DustDetector" => DustDetector
    case "ElectronDriftInstrument" => ElectronDriftInstrument
    case "ElectrostaticAnalyser" => ElectrostaticAnalyser
    case "EnergeticParticleInstrument" => EnergeticParticleInstrument
    case "FaradayCup" => FaradayCup
    case "FluxFeedback" => FluxFeedback
    case "FourierTransformSpectrograph" => FourierTransformSpectrograph
    case "GeigerMuellerTube" => GeigerMuellerTube
    case "Imager" => Imager
    case "ImagingSpectrometer" => ImagingSpectrometer
    case "Interferometer" => Interferometer
    case "IonChamber" => IonChamber
    case "IonDrift" => IonDrift
    case "LangmuirProbe" => LangmuirProbe
    case "LongWire" => LongWire
    case "Magnetometer" => Magnetometer
    case "MassSpectrometer" => MassSpectrometer
    case "MicrochannelPlate" => MicrochannelPlate
    case "MultispectralImager" => MultispectralImager
    case "NeutralAtomImager" => NeutralAtomImager
    case "NeutralParticleDetector" => NeutralParticleDetector
    case "ParticleCorrelator" => ParticleCorrelator
    case "ParticleDetector" => ParticleDetector
    case "Photometer" => Photometer
    case "Photopolarimeter" => Photopolarimeter
    case "Platform" => Platform
    case "ProportionalCounter" => ProportionalCounter
    case "QuadrisphericalAnalyser" => QuadrisphericalAnalyser
    case "Radar" => Radar
    case "Radiometer" => Radiometer
    case "ResonanceSounder" => ResonanceSounder
    case "RetardingPotentialAnalyser" => RetardingPotentialAnalyser
    case "Riometer" => Riometer
    case "ScintillationDetector" => ScintillationDetector
    case "SearchCoil" => SearchCoil
    case "Sounder" => Sounder
    case "SpacecraftPotentialControl" => SpacecraftPotentialControl
    case "SpectralPowerReceiver" => SpectralPowerReceiver
    case "Spectrometer" => Spectrometer
    case "TimeOfFlight" => TimeOfFlight
    case "Unspecified" => Unspecified
    case "WaveformReceiver" => WaveformReceiver

  }
}

case object Antenna extends EnumInstrumentType { override def toString = "Antenna" }
case object Channeltron extends EnumInstrumentType { override def toString = "Channeltron" }
case object Coronograph extends EnumInstrumentType { override def toString = "Coronograph" }
case object DoubleSphere extends EnumInstrumentType { override def toString = "DoubleSphere" }
case object DustDetector extends EnumInstrumentType { override def toString = "DustDetector" }
case object ElectronDriftInstrument extends EnumInstrumentType { override def toString = "ElectronDriftInstrument" }
case object ElectrostaticAnalyser extends EnumInstrumentType { override def toString = "ElectrostaticAnalyser" }
case object EnergeticParticleInstrument extends EnumInstrumentType { override def toString = "EnergeticParticleInstrument" }
case object FaradayCup extends EnumInstrumentType { override def toString = "FaradayCup" }
case object FluxFeedback extends EnumInstrumentType { override def toString = "FluxFeedback" }
case object FourierTransformSpectrograph extends EnumInstrumentType { override def toString = "FourierTransformSpectrograph" }
case object GeigerMuellerTube extends EnumInstrumentType { override def toString = "GeigerMuellerTube" }
case object Imager extends EnumInstrumentType { override def toString = "Imager" }
case object ImagingSpectrometer extends EnumInstrumentType { override def toString = "ImagingSpectrometer" }
case object Interferometer extends EnumInstrumentType { override def toString = "Interferometer" }
case object IonChamber extends EnumInstrumentType { override def toString = "IonChamber" }
case object IonDrift extends EnumInstrumentType { override def toString = "IonDrift" }
case object LangmuirProbe extends EnumInstrumentType { override def toString = "LangmuirProbe" }
case object LongWire extends EnumInstrumentType { override def toString = "LongWire" }
case object Magnetometer extends EnumInstrumentType { override def toString = "Magnetometer" }
case object MassSpectrometer extends EnumInstrumentType { override def toString = "MassSpectrometer" }
case object MicrochannelPlate extends EnumInstrumentType { override def toString = "MicrochannelPlate" }
case object MultispectralImager extends EnumInstrumentType { override def toString = "MultispectralImager" }
case object NeutralAtomImager extends EnumInstrumentType { override def toString = "NeutralAtomImager" }
case object NeutralParticleDetector extends EnumInstrumentType { override def toString = "NeutralParticleDetector" }
case object ParticleCorrelator extends EnumInstrumentType { override def toString = "ParticleCorrelator" }
case object ParticleDetector extends EnumInstrumentType { override def toString = "ParticleDetector" }
case object Photometer extends EnumInstrumentType { override def toString = "Photometer" }
case object Photopolarimeter extends EnumInstrumentType { override def toString = "Photopolarimeter" }
case object Platform extends EnumInstrumentType { override def toString = "Platform" }
case object ProportionalCounter extends EnumInstrumentType { override def toString = "ProportionalCounter" }
case object QuadrisphericalAnalyser extends EnumInstrumentType { override def toString = "QuadrisphericalAnalyser" }
case object Radar extends EnumInstrumentType { override def toString = "Radar" }
case object Radiometer extends EnumInstrumentType { override def toString = "Radiometer" }
case object ResonanceSounder extends EnumInstrumentType { override def toString = "ResonanceSounder" }
case object RetardingPotentialAnalyser extends EnumInstrumentType { override def toString = "RetardingPotentialAnalyser" }
case object Riometer extends EnumInstrumentType { override def toString = "Riometer" }
case object ScintillationDetector extends EnumInstrumentType { override def toString = "ScintillationDetector" }
case object SearchCoil extends EnumInstrumentType { override def toString = "SearchCoil" }
case object Sounder extends EnumInstrumentType { override def toString = "Sounder" }
case object SpacecraftPotentialControl extends EnumInstrumentType { override def toString = "SpacecraftPotentialControl" }
case object SpectralPowerReceiver extends EnumInstrumentType { override def toString = "SpectralPowerReceiver" }
case object Spectrometer extends EnumInstrumentType { override def toString = "Spectrometer" }
case object TimeOfFlight extends EnumInstrumentType { override def toString = "TimeOfFlight" }
case object Unspecified extends EnumInstrumentType { override def toString = "Unspecified" }
case object WaveformReceiver extends EnumInstrumentType { override def toString = "WaveformReceiver" }

trait EnumIntegral

object EnumIntegral {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumIntegral = value match {
    case "Area" => Area
    case "Bandwidth" => Bandwidth
    case "SolidAngle" => SolidAngle

  }
}

case object Area extends EnumIntegral { override def toString = "Area" }
case object Bandwidth extends EnumIntegral { override def toString = "Bandwidth" }
case object SolidAngle extends EnumIntegral { override def toString = "SolidAngle" }

trait EnumIonosphere

object EnumIonosphere {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumIonosphere = value match {
    case "DRegion" => DRegion
    case "ERegion" => ERegion
    case "FRegion" => FRegion
    case "Topside" => Topside

  }
}

case object DRegion extends EnumIonosphere { override def toString = "DRegion" }
case object ERegion extends EnumIonosphere { override def toString = "ERegion" }
case object FRegion extends EnumIonosphere { override def toString = "FRegion" }
case object Topside extends EnumIonosphere { override def toString = "Topside" }

trait EnumMagnetosphere

object EnumMagnetosphere {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumMagnetosphere = value match {
    case "Magnetotail" => Magnetotail
    case "Main" => Main
    case "Polar" => Polar
    case "RadiationBelt" => RadiationBelt

  }
}

case object Magnetotail extends EnumMagnetosphere { override def toString = "Magnetotail" }
case object Main extends EnumMagnetosphere { override def toString = "Main" }
case object Polar extends EnumMagnetosphere { override def toString = "Polar" }
case object RadiationBelt extends EnumMagnetosphere { override def toString = "RadiationBelt" }

trait EnumMeasurementType

object EnumMeasurementType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumMeasurementType = value match {
    case "Current" => Current
    case "ActivityIndex" => ActivityIndex
    case "Dopplergram" => Dopplergram
    case "Dust" => DustValue
    case "ElectricField" => ElectricField
    case "EnergeticParticles" => EnergeticParticles
    case "Ephemeris" => Ephemeris
    case "ImageIntensity" => ImageIntensity
    case "InstrumentStatus" => InstrumentStatus
    case "IonComposition" => IonComposition
    case "Irradiance" => Irradiance
    case "MagneticField" => MagneticField
    case "Magnetogram" => Magnetogram
    case "NeutralAtomImages" => NeutralAtomImages
    case "NeutralGas" => NeutralGas
    case "Profile" => Profile
    case "Radiance" => Radiance
    case "Spectrum" => Spectrum
    case "ThermalPlasma" => ThermalPlasma
    case "Waves" => Waves
    case "Waves.Active" => Wavesu46Active
    case "Waves.Passive" => Wavesu46Passive

  }
}

case object Current extends EnumMeasurementType { override def toString = "Current" }
case object ActivityIndex extends EnumMeasurementType { override def toString = "ActivityIndex" }
case object Dopplergram extends EnumMeasurementType { override def toString = "Dopplergram" }
case object DustValue extends EnumMeasurementType { override def toString = "Dust" }
case object ElectricField extends EnumMeasurementType { override def toString = "ElectricField" }
case object EnergeticParticles extends EnumMeasurementType { override def toString = "EnergeticParticles" }
case object Ephemeris extends EnumMeasurementType { override def toString = "Ephemeris" }
case object ImageIntensity extends EnumMeasurementType { override def toString = "ImageIntensity" }
case object InstrumentStatus extends EnumMeasurementType { override def toString = "InstrumentStatus" }
case object IonComposition extends EnumMeasurementType { override def toString = "IonComposition" }
case object Irradiance extends EnumMeasurementType { override def toString = "Irradiance" }
case object MagneticField extends EnumMeasurementType { override def toString = "MagneticField" }
case object Magnetogram extends EnumMeasurementType { override def toString = "Magnetogram" }
case object NeutralAtomImages extends EnumMeasurementType { override def toString = "NeutralAtomImages" }
case object NeutralGas extends EnumMeasurementType { override def toString = "NeutralGas" }
case object Profile extends EnumMeasurementType { override def toString = "Profile" }
case object Radiance extends EnumMeasurementType { override def toString = "Radiance" }
case object Spectrum extends EnumMeasurementType { override def toString = "Spectrum" }
case object ThermalPlasma extends EnumMeasurementType { override def toString = "ThermalPlasma" }
case object Waves extends EnumMeasurementType { override def toString = "Waves" }
case object Wavesu46Active extends EnumMeasurementType { override def toString = "Waves.Active" }
case object Wavesu46Passive extends EnumMeasurementType { override def toString = "Waves.Passive" }

trait EnumMixedQuantity

object EnumMixedQuantity {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumMixedQuantity = value match {
    case "AkasofuEpsilon" => AkasofuEpsilon
    case "AlfvenMachNumber" => AlfvenMachNumber
    case "AlfvenVelocity" => AlfvenVelocity
    case "FrequencyToGyrofrequencyRatio" => FrequencyToGyrofrequencyRatio
    case "MagnetosonicMachNumber" => MagnetosonicMachNumber
    case "Other" => OtherValue2
    case "PlasmaBeta" => PlasmaBeta
    case "TotalPressure" => TotalPressure
    case "VCrossB" => VCrossB

  }
}

case object AkasofuEpsilon extends EnumMixedQuantity { override def toString = "AkasofuEpsilon" }
case object AlfvenMachNumber extends EnumMixedQuantity { override def toString = "AlfvenMachNumber" }
case object AlfvenVelocity extends EnumMixedQuantity { override def toString = "AlfvenVelocity" }
case object FrequencyToGyrofrequencyRatio extends EnumMixedQuantity { override def toString = "FrequencyToGyrofrequencyRatio" }
case object MagnetosonicMachNumber extends EnumMixedQuantity { override def toString = "MagnetosonicMachNumber" }
case object OtherValue2 extends EnumMixedQuantity { override def toString = "Other" }
case object PlasmaBeta extends EnumMixedQuantity { override def toString = "PlasmaBeta" }
case object TotalPressure extends EnumMixedQuantity { override def toString = "TotalPressure" }
case object VCrossB extends EnumMixedQuantity { override def toString = "VCrossB" }

trait EnumNearSurface

object EnumNearSurface {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumNearSurface = value match {
    case "Atmosphere" => Atmosphere
    case "AuroralRegion" => AuroralRegion
    case "EquatorialRegion" => EquatorialRegion
    case "Ionosphere" => Ionosphere
    case "Ionosphere.DRegion" => Ionosphereu46DRegion
    case "Ionosphere.ERegion" => Ionosphereu46ERegion
    case "Ionosphere.FRegion" => Ionosphereu46FRegion
    case "Ionosphere.Topside" => Ionosphereu46Topside
    case "Mesosphere" => Mesosphere
    case "Plasmasphere" => Plasmasphere
    case "PolarCap" => PolarCap
    case "SouthAtlanticAnomalyRegion" => SouthAtlanticAnomalyRegion
    case "Stratosphere" => Stratosphere
    case "Thermosphere" => Thermosphere
    case "Troposphere" => Troposphere

  }
}

case object Atmosphere extends EnumNearSurface { override def toString = "Atmosphere" }
case object AuroralRegion extends EnumNearSurface { override def toString = "AuroralRegion" }
case object EquatorialRegion extends EnumNearSurface { override def toString = "EquatorialRegion" }
case object Ionosphere extends EnumNearSurface { override def toString = "Ionosphere" }
case object Ionosphereu46DRegion extends EnumNearSurface { override def toString = "Ionosphere.DRegion" }
case object Ionosphereu46ERegion extends EnumNearSurface { override def toString = "Ionosphere.ERegion" }
case object Ionosphereu46FRegion extends EnumNearSurface { override def toString = "Ionosphere.FRegion" }
case object Ionosphereu46Topside extends EnumNearSurface { override def toString = "Ionosphere.Topside" }
case object Mesosphere extends EnumNearSurface { override def toString = "Mesosphere" }
case object Plasmasphere extends EnumNearSurface { override def toString = "Plasmasphere" }
case object PolarCap extends EnumNearSurface { override def toString = "PolarCap" }
case object SouthAtlanticAnomalyRegion extends EnumNearSurface { override def toString = "SouthAtlanticAnomalyRegion" }
case object Stratosphere extends EnumNearSurface { override def toString = "Stratosphere" }
case object Thermosphere extends EnumNearSurface { override def toString = "Thermosphere" }
case object Troposphere extends EnumNearSurface { override def toString = "Troposphere" }

trait EnumParticleQuantity

object EnumParticleQuantity {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumParticleQuantity = value match {
    case "ArrivalDirection" => ArrivalDirection
    case "AtomicNumberDetected" => AtomicNumberDetected
    case "AverageChargeState" => AverageChargeState
    case "ChargeState" => ChargeState
    case "CountRate" => CountRate
    case "Counts" => Counts
    case "Energy" => Energy
    case "EnergyDensity" => EnergyDensity
    case "EnergyFlux" => EnergyFlux
    case "FlowSpeed" => FlowSpeed
    case "FlowVelocity" => FlowVelocity
    case "Fluence" => Fluence
    case "Gyrofrequency" => GyrofrequencyValue
    case "HeatFlux" => HeatFlux
    case "Mass" => Mass
    case "MassDensity" => MassDensity
    case "MassNumber" => MassNumber
    case "NumberDensity" => NumberDensity
    case "NumberFlux" => NumberFlux
    case "ParticleRadius" => ParticleRadius
    case "PhaseSpaceDensity" => PhaseSpaceDensity
    case "PlasmaFrequency" => PlasmaFrequencyValue
    case "Pressure" => Pressure
    case "SonicMachNumber" => SonicMachNumber
    case "SoundSpeed" => SoundSpeed
    case "Temperature" => Temperature
    case "ThermalSpeed" => ThermalSpeed
    case "Velocity" => Velocity

  }
}

case object ArrivalDirection extends EnumParticleQuantity { override def toString = "ArrivalDirection" }
case object AtomicNumberDetected extends EnumParticleQuantity { override def toString = "AtomicNumberDetected" }
case object AverageChargeState extends EnumParticleQuantity { override def toString = "AverageChargeState" }
case object ChargeState extends EnumParticleQuantity { override def toString = "ChargeState" }
case object CountRate extends EnumParticleQuantity { override def toString = "CountRate" }
case object Counts extends EnumParticleQuantity { override def toString = "Counts" }
case object Energy extends EnumParticleQuantity { override def toString = "Energy" }
case object EnergyDensity extends EnumParticleQuantity { override def toString = "EnergyDensity" }
case object EnergyFlux extends EnumParticleQuantity { override def toString = "EnergyFlux" }
case object FlowSpeed extends EnumParticleQuantity { override def toString = "FlowSpeed" }
case object FlowVelocity extends EnumParticleQuantity { override def toString = "FlowVelocity" }
case object Fluence extends EnumParticleQuantity { override def toString = "Fluence" }
case object GyrofrequencyValue extends EnumParticleQuantity { override def toString = "Gyrofrequency" }
case object HeatFlux extends EnumParticleQuantity { override def toString = "HeatFlux" }
case object Mass extends EnumParticleQuantity { override def toString = "Mass" }
case object MassDensity extends EnumParticleQuantity { override def toString = "MassDensity" }
case object MassNumber extends EnumParticleQuantity { override def toString = "MassNumber" }
case object NumberDensity extends EnumParticleQuantity { override def toString = "NumberDensity" }
case object NumberFlux extends EnumParticleQuantity { override def toString = "NumberFlux" }
case object ParticleRadius extends EnumParticleQuantity { override def toString = "ParticleRadius" }
case object PhaseSpaceDensity extends EnumParticleQuantity { override def toString = "PhaseSpaceDensity" }
case object PlasmaFrequencyValue extends EnumParticleQuantity { override def toString = "PlasmaFrequency" }
case object Pressure extends EnumParticleQuantity { override def toString = "Pressure" }
case object SonicMachNumber extends EnumParticleQuantity { override def toString = "SonicMachNumber" }
case object SoundSpeed extends EnumParticleQuantity { override def toString = "SoundSpeed" }
case object Temperature extends EnumParticleQuantity { override def toString = "Temperature" }
case object ThermalSpeed extends EnumParticleQuantity { override def toString = "ThermalSpeed" }
case object Velocity extends EnumParticleQuantity { override def toString = "Velocity" }

trait EnumParticleType

object EnumParticleType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumParticleType = value match {
    case "Aerosol" => Aerosol
    case "AlphaParticle" => AlphaParticle
    case "Atom" => Atom
    case "Dust" => Dust
    case "Electron" => Electron
    case "Ion" => Ion
    case "Molecule" => Molecule
    case "Neutron" => Neutron
    case "Proton" => Proton

  }
}

case object Aerosol extends EnumParticleType { override def toString = "Aerosol" }
case object AlphaParticle extends EnumParticleType { override def toString = "AlphaParticle" }
case object Atom extends EnumParticleType { override def toString = "Atom" }
case object Dust extends EnumParticleType { override def toString = "Dust" }
case object Electron extends EnumParticleType { override def toString = "Electron" }
case object Ion extends EnumParticleType { override def toString = "Ion" }
case object Molecule extends EnumParticleType { override def toString = "Molecule" }
case object Neutron extends EnumParticleType { override def toString = "Neutron" }
case object Proton extends EnumParticleType { override def toString = "Proton" }

trait EnumPhenomenonType

object EnumPhenomenonType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumPhenomenonType = value match {
    case "ActiveRegion" => ActiveRegion
    case "Aurora" => Aurora
    case "BowShockCrossing" => BowShockCrossing
    case "CoronalHole" => CoronalHole
    case "CoronalMassEjection" => CoronalMassEjection
    case "EITWave" => EITWave
    case "EnergeticSolarParticleEvent" => EnergeticSolarParticleEvent
    case "ForbushDecrease" => ForbushDecrease
    case "GeomagneticStorm" => GeomagneticStorm
    case "InterplanetaryShock" => InterplanetaryShock
    case "MagneticCloud" => MagneticCloud
    case "MagnetopauseCrossing" => MagnetopauseCrossing
    case "RadioBurst" => RadioBurst
    case "SectorBoundaryCrossing" => SectorBoundaryCrossing
    case "SolarFlare" => SolarFlare
    case "SolarWindExtreme" => SolarWindExtreme
    case "StreamInteractionRegion" => StreamInteractionRegion
    case "Substorm" => Substorm

  }
}

case object ActiveRegion extends EnumPhenomenonType { override def toString = "ActiveRegion" }
case object Aurora extends EnumPhenomenonType { override def toString = "Aurora" }
case object BowShockCrossing extends EnumPhenomenonType { override def toString = "BowShockCrossing" }
case object CoronalHole extends EnumPhenomenonType { override def toString = "CoronalHole" }
case object CoronalMassEjection extends EnumPhenomenonType { override def toString = "CoronalMassEjection" }
case object EITWave extends EnumPhenomenonType { override def toString = "EITWave" }
case object EnergeticSolarParticleEvent extends EnumPhenomenonType { override def toString = "EnergeticSolarParticleEvent" }
case object ForbushDecrease extends EnumPhenomenonType { override def toString = "ForbushDecrease" }
case object GeomagneticStorm extends EnumPhenomenonType { override def toString = "GeomagneticStorm" }
case object InterplanetaryShock extends EnumPhenomenonType { override def toString = "InterplanetaryShock" }
case object MagneticCloud extends EnumPhenomenonType { override def toString = "MagneticCloud" }
case object MagnetopauseCrossing extends EnumPhenomenonType { override def toString = "MagnetopauseCrossing" }
case object RadioBurst extends EnumPhenomenonType { override def toString = "RadioBurst" }
case object SectorBoundaryCrossing extends EnumPhenomenonType { override def toString = "SectorBoundaryCrossing" }
case object SolarFlare extends EnumPhenomenonType { override def toString = "SolarFlare" }
case object SolarWindExtreme extends EnumPhenomenonType { override def toString = "SolarWindExtreme" }
case object StreamInteractionRegion extends EnumPhenomenonType { override def toString = "StreamInteractionRegion" }
case object Substorm extends EnumPhenomenonType { override def toString = "Substorm" }

trait EnumProcessingLevel

object EnumProcessingLevel {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumProcessingLevel = value match {
    case "Calibrated" => Calibrated
    case "Raw" => Raw
    case "Uncalibrated" => Uncalibrated

  }
}

case object Calibrated extends EnumProcessingLevel { override def toString = "Calibrated" }
case object Raw extends EnumProcessingLevel { override def toString = "Raw" }
case object Uncalibrated extends EnumProcessingLevel { override def toString = "Uncalibrated" }

trait EnumProjection

object EnumProjection {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumProjection = value match {
    case "IJ" => IJ
    case "IK" => IK
    case "JK" => JK

  }
}

case object IJ extends EnumProjection { override def toString = "IJ" }
case object IK extends EnumProjection { override def toString = "IK" }
case object JK extends EnumProjection { override def toString = "JK" }

trait EnumImpexSpecialRegion

object EnumImpexSpecialRegion {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumImpexSpecialRegion = value match {
    case "Incident" => Incident

  }
}

case object Incident extends EnumImpexSpecialRegion { override def toString = "Incident" }

trait EnumQualifier

object EnumQualifier {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumQualifier = value match {
    case "Anisotropy" => Anisotropy
    case "Array" => ArrayType
    case "Average" => Average
    case "Characteristic" => Characteristic
    case "Circular" => Circular
    case "Column" => Column
    case "Component" => ComponentValue
    case "Component.I" => Componentu46I
    case "Component.J" => Componentu46J
    case "Component.K" => Componentu46K
    case "Core" => Core
    case "CrossSpectrum" => CrossSpectrum
    case "Deviation" => Deviation
    case "Differential" => Differential
    case "Direction" => Direction
    case "DirectionAngle" => DirectionAngle
    case "DirectionAngle.AzimuthAngle" => DirectionAngleu46AzimuthAngle
    case "DirectionAngle.ElevationAngle" => DirectionAngleu46ElevationAngle
    case "DirectionAngle.PolarAngle" => DirectionAngleu46PolarAngle
    case "Directional" => Directional
    case "FieldAligned" => FieldAligned
    case "Fit" => Fit
    case "Group" => GroupValue
    case "Halo" => Halo
    case "Integral" => Integral
    case "Integral.Area" => Integralu46Area
    case "Integral.Bandwidth" => Integralu46Bandwidth
    case "Integral.SolidAngle" => Integralu46SolidAngle
    case "LineOfSight" => LineOfSight
    case "Linear" => Linear
    case "Magnitude" => Magnitude
    case "Maximum" => Maximum
    case "Median" => Median
    case "Minimum" => Minimum
    case "Moment" => Moment
    case "Parallel" => Parallel
    case "Peak" => Peak
    case "Perpendicular" => Perpendicular
    case "Perturbation" => Perturbation
    case "Phase" => Phase
    case "PhaseAngle" => PhaseAngle
    case "Projection" => Projection
    case "Projection.IJ" => Projectionu46IJ
    case "Projection.IK" => Projectionu46IK
    case "Projection.JK" => Projectionu46JK
    case "Pseudo" => Pseudo
    case "Ratio" => Ratio
    case "Scalar" => Scalar
    case "Spectral" => Spectral
    case "StandardDeviation" => StandardDeviation
    case "StokesParameters" => StokesParameters
    case "Strahl" => Strahl
    case "Superhalo" => Superhalo
    case "Symmetric" => Symmetric
    case "Tensor" => Tensor
    case "Total" => Total
    case "Trace" => Trace
    case "Uncertainty" => Uncertainty
    case "Variance" => Variance
    case "Vector" => Vector

  }
}

case object Anisotropy extends EnumQualifier { override def toString = "Anisotropy" }
case object ArrayType extends EnumQualifier { override def toString = "Array" }
case object Average extends EnumQualifier { override def toString = "Average" }
case object Characteristic extends EnumQualifier { override def toString = "Characteristic" }
case object Circular extends EnumQualifier { override def toString = "Circular" }
case object Column extends EnumQualifier { override def toString = "Column" }
case object ComponentValue extends EnumQualifier { override def toString = "Component" }
case object Componentu46I extends EnumQualifier { override def toString = "Component.I" }
case object Componentu46J extends EnumQualifier { override def toString = "Component.J" }
case object Componentu46K extends EnumQualifier { override def toString = "Component.K" }
case object Core extends EnumQualifier { override def toString = "Core" }
case object CrossSpectrum extends EnumQualifier { override def toString = "CrossSpectrum" }
case object Deviation extends EnumQualifier { override def toString = "Deviation" }
case object Differential extends EnumQualifier { override def toString = "Differential" }
case object Direction extends EnumQualifier { override def toString = "Direction" }
case object DirectionAngle extends EnumQualifier { override def toString = "DirectionAngle" }
case object DirectionAngleu46AzimuthAngle extends EnumQualifier { override def toString = "DirectionAngle.AzimuthAngle" }
case object DirectionAngleu46ElevationAngle extends EnumQualifier { override def toString = "DirectionAngle.ElevationAngle" }
case object DirectionAngleu46PolarAngle extends EnumQualifier { override def toString = "DirectionAngle.PolarAngle" }
case object Directional extends EnumQualifier { override def toString = "Directional" }
case object FieldAligned extends EnumQualifier { override def toString = "FieldAligned" }
case object Fit extends EnumQualifier { override def toString = "Fit" }
case object GroupValue extends EnumQualifier { override def toString = "Group" }
case object Halo extends EnumQualifier { override def toString = "Halo" }
case object Integral extends EnumQualifier { override def toString = "Integral" }
case object Integralu46Area extends EnumQualifier { override def toString = "Integral.Area" }
case object Integralu46Bandwidth extends EnumQualifier { override def toString = "Integral.Bandwidth" }
case object Integralu46SolidAngle extends EnumQualifier { override def toString = "Integral.SolidAngle" }
case object LineOfSight extends EnumQualifier { override def toString = "LineOfSight" }
case object Linear extends EnumQualifier { override def toString = "Linear" }
case object Magnitude extends EnumQualifier { override def toString = "Magnitude" }
case object Maximum extends EnumQualifier { override def toString = "Maximum" }
case object Median extends EnumQualifier { override def toString = "Median" }
case object Minimum extends EnumQualifier { override def toString = "Minimum" }
case object Moment extends EnumQualifier { override def toString = "Moment" }
case object Parallel extends EnumQualifier { override def toString = "Parallel" }
case object Peak extends EnumQualifier { override def toString = "Peak" }
case object Perpendicular extends EnumQualifier { override def toString = "Perpendicular" }
case object Perturbation extends EnumQualifier { override def toString = "Perturbation" }
case object Phase extends EnumQualifier { override def toString = "Phase" }
case object PhaseAngle extends EnumQualifier { override def toString = "PhaseAngle" }
case object Projection extends EnumQualifier { override def toString = "Projection" }
case object Projectionu46IJ extends EnumQualifier { override def toString = "Projection.IJ" }
case object Projectionu46IK extends EnumQualifier { override def toString = "Projection.IK" }
case object Projectionu46JK extends EnumQualifier { override def toString = "Projection.JK" }
case object Pseudo extends EnumQualifier { override def toString = "Pseudo" }
case object Ratio extends EnumQualifier { override def toString = "Ratio" }
case object Scalar extends EnumQualifier { override def toString = "Scalar" }
case object Spectral extends EnumQualifier { override def toString = "Spectral" }
case object StandardDeviation extends EnumQualifier { override def toString = "StandardDeviation" }
case object StokesParameters extends EnumQualifier { override def toString = "StokesParameters" }
case object Strahl extends EnumQualifier { override def toString = "Strahl" }
case object Superhalo extends EnumQualifier { override def toString = "Superhalo" }
case object Symmetric extends EnumQualifier { override def toString = "Symmetric" }
case object Tensor extends EnumQualifier { override def toString = "Tensor" }
case object Total extends EnumQualifier { override def toString = "Total" }
case object Trace extends EnumQualifier { override def toString = "Trace" }
case object Uncertainty extends EnumQualifier { override def toString = "Uncertainty" }
case object Variance extends EnumQualifier { override def toString = "Variance" }
case object Vector extends EnumQualifier { override def toString = "Vector" }

trait EnumRegion

object EnumRegion {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumRegion = value match {
    case "Asteroid" => Asteroid
    case "Callisto" => Callisto
    case "Comet" => Comet
    case "Earth" => Earth
    case "Earth.Magnetosheath" => Earthu46Magnetosheath
    case "Earth.Magnetosphere" => Earthu46Magnetosphere
    case "Earth.Magnetosphere.Magnetotail" => Earthu46Magnetosphereu46Magnetotail
    case "Earth.Magnetosphere.Main" => Earthu46Magnetosphereu46Main
    case "Earth.Magnetosphere.Polar" => Earthu46Magnetosphereu46Polar
    case "Earth.Magnetosphere.RadiationBelt" => Earthu46Magnetosphereu46RadiationBelt
    case "Earth.NearSurface" => Earthu46NearSurface
    case "Earth.NearSurface.Atmosphere" => Earthu46NearSurfaceu46Atmosphere
    case "Earth.NearSurface.AuroralRegion" => Earthu46NearSurfaceu46AuroralRegion
    case "Earth.NearSurface.EquatorialRegion" => Earthu46NearSurfaceu46EquatorialRegion
    case "Earth.NearSurface.Ionosphere" => Earthu46NearSurfaceu46Ionosphere
    case "Earth.NearSurface.Ionosphere.DRegion" => Earthu46NearSurfaceu46Ionosphereu46DRegion
    case "Earth.NearSurface.Ionosphere.ERegion" => Earthu46NearSurfaceu46Ionosphereu46ERegion
    case "Earth.NearSurface.Ionosphere.FRegion" => Earthu46NearSurfaceu46Ionosphereu46FRegion
    case "Earth.NearSurface.Ionosphere.Topside" => Earthu46NearSurfaceu46Ionosphereu46Topside
    case "Earth.NearSurface.Mesosphere" => Earthu46NearSurfaceu46Mesosphere
    case "Earth.NearSurface.Plasmasphere" => Earthu46NearSurfaceu46Plasmasphere
    case "Earth.NearSurface.PolarCap" => Earthu46NearSurfaceu46PolarCap
    case "Earth.NearSurface.SouthAtlanticAnomalyRegion" => Earthu46NearSurfaceu46SouthAtlanticAnomalyRegion
    case "Earth.NearSurface.Stratosphere" => Earthu46NearSurfaceu46Stratosphere
    case "Earth.NearSurface.Thermosphere" => Earthu46NearSurfaceu46Thermosphere
    case "Earth.NearSurface.Troposphere" => Earthu46NearSurfaceu46Troposphere
    case "Earth.Surface" => Earthu46Surface
    case "Enceladus" => Enceladus
    case "Europa" => Europa
    case "Ganymede" => Ganymede
    case "Heliosphere" => Heliosphere
    case "Heliosphere.Heliosheath" => Heliosphereu46Heliosheath
    case "Heliosphere.Inner" => Heliosphereu46Inner
    case "Heliosphere.NearEarth" => Heliosphereu46NearEarth
    case "Heliosphere.Outer" => Heliosphereu46Outer
    case "Heliosphere.Remote1AU" => Heliosphereu46Remote1AU
    case "Interstellar" => Interstellar
    case "Io" => Io
    case "Jupiter" => Jupiter
    case "Jupiter.Magnetosphere" => Jupiteru46Magnetosphere
    case "Mars" => Mars
    case "Mercury" => Mercury
    case "Mercury.Magnetosphere" => Mercuryu46Magnetosphere
    case "Neptune" => Neptune
    case "Planet" => Planet
    case "Planet.Magnetosphere" => Planetu46Magnetosphere
    case "Pluto" => Pluto
    case "Rhea" => Rhea
    case "Saturn" => Saturn
    case "Saturn.Magnetosphere" => Saturnu46Magnetosphere
    case "Sun" => Sun
    case "Sun.Chromosphere" => Sunu46Chromosphere
    case "Sun.Corona" => Sunu46Corona
    case "Sun.Interior" => Sunu46Interior
    case "Sun.Photosphere" => Sunu46Photosphere
    case "Sun.TransitionRegion" => Sunu46TransitionRegion
    case "Titan" => Titan
    case "Uranus" => Uranus
    case "Venus" => Venus

  }
}

case object Asteroid extends EnumRegion { override def toString = "Asteroid" }
case object Callisto extends EnumRegion { override def toString = "Callisto" }
case object Comet extends EnumRegion { override def toString = "Comet" }
case object Earth extends EnumRegion { override def toString = "Earth" }
case object Earthu46Magnetosheath extends EnumRegion { override def toString = "Earth.Magnetosheath" }
case object Earthu46Magnetosphere extends EnumRegion { override def toString = "Earth.Magnetosphere" }
case object Earthu46Magnetosphereu46Magnetotail extends EnumRegion { override def toString = "Earth.Magnetosphere.Magnetotail" }
case object Earthu46Magnetosphereu46Main extends EnumRegion { override def toString = "Earth.Magnetosphere.Main" }
case object Earthu46Magnetosphereu46Polar extends EnumRegion { override def toString = "Earth.Magnetosphere.Polar" }
case object Earthu46Magnetosphereu46RadiationBelt extends EnumRegion { override def toString = "Earth.Magnetosphere.RadiationBelt" }
case object Earthu46NearSurface extends EnumRegion { override def toString = "Earth.NearSurface" }
case object Earthu46NearSurfaceu46Atmosphere extends EnumRegion { override def toString = "Earth.NearSurface.Atmosphere" }
case object Earthu46NearSurfaceu46AuroralRegion extends EnumRegion { override def toString = "Earth.NearSurface.AuroralRegion" }
case object Earthu46NearSurfaceu46EquatorialRegion extends EnumRegion { override def toString = "Earth.NearSurface.EquatorialRegion" }
case object Earthu46NearSurfaceu46Ionosphere extends EnumRegion { override def toString = "Earth.NearSurface.Ionosphere" }
case object Earthu46NearSurfaceu46Ionosphereu46DRegion extends EnumRegion { override def toString = "Earth.NearSurface.Ionosphere.DRegion" }
case object Earthu46NearSurfaceu46Ionosphereu46ERegion extends EnumRegion { override def toString = "Earth.NearSurface.Ionosphere.ERegion" }
case object Earthu46NearSurfaceu46Ionosphereu46FRegion extends EnumRegion { override def toString = "Earth.NearSurface.Ionosphere.FRegion" }
case object Earthu46NearSurfaceu46Ionosphereu46Topside extends EnumRegion { override def toString = "Earth.NearSurface.Ionosphere.Topside" }
case object Earthu46NearSurfaceu46Mesosphere extends EnumRegion { override def toString = "Earth.NearSurface.Mesosphere" }
case object Earthu46NearSurfaceu46Plasmasphere extends EnumRegion { override def toString = "Earth.NearSurface.Plasmasphere" }
case object Earthu46NearSurfaceu46PolarCap extends EnumRegion { override def toString = "Earth.NearSurface.PolarCap" }
case object Earthu46NearSurfaceu46SouthAtlanticAnomalyRegion extends EnumRegion { override def toString = "Earth.NearSurface.SouthAtlanticAnomalyRegion" }
case object Earthu46NearSurfaceu46Stratosphere extends EnumRegion { override def toString = "Earth.NearSurface.Stratosphere" }
case object Earthu46NearSurfaceu46Thermosphere extends EnumRegion { override def toString = "Earth.NearSurface.Thermosphere" }
case object Earthu46NearSurfaceu46Troposphere extends EnumRegion { override def toString = "Earth.NearSurface.Troposphere" }
case object Earthu46Surface extends EnumRegion { override def toString = "Earth.Surface" }
case object Enceladus extends EnumRegion { override def toString = "Enceladus" }
case object Europa extends EnumRegion { override def toString = "Europa" }
case object Ganymede extends EnumRegion { override def toString = "Ganymede" }
case object Heliosphere extends EnumRegion { override def toString = "Heliosphere" }
case object Heliosphereu46Heliosheath extends EnumRegion { override def toString = "Heliosphere.Heliosheath" }
case object Heliosphereu46Inner extends EnumRegion { override def toString = "Heliosphere.Inner" }
case object Heliosphereu46NearEarth extends EnumRegion { override def toString = "Heliosphere.NearEarth" }
case object Heliosphereu46Outer extends EnumRegion { override def toString = "Heliosphere.Outer" }
case object Heliosphereu46Remote1AU extends EnumRegion { override def toString = "Heliosphere.Remote1AU" }
case object Interstellar extends EnumRegion { override def toString = "Interstellar" }
case object Io extends EnumRegion { override def toString = "Io" }
case object Jupiter extends EnumRegion { override def toString = "Jupiter" }
case object Jupiteru46Magnetosphere extends EnumRegion { override def toString = "Jupiter.Magnetosphere" }
case object Mars extends EnumRegion { override def toString = "Mars" }
case object Mercury extends EnumRegion { override def toString = "Mercury" }
case object Mercuryu46Magnetosphere extends EnumRegion { override def toString = "Mercury.Magnetosphere" }
case object Neptune extends EnumRegion { override def toString = "Neptune" }
case object Planet extends EnumRegion { override def toString = "Planet" }
case object Planetu46Magnetosphere extends EnumRegion { override def toString = "Planet.Magnetosphere" }
case object Pluto extends EnumRegion { override def toString = "Pluto" }
case object Rhea extends EnumRegion { override def toString = "Rhea" }
case object Saturn extends EnumRegion { override def toString = "Saturn" }
case object Saturnu46Magnetosphere extends EnumRegion { override def toString = "Saturn.Magnetosphere" }
case object Sun extends EnumRegion { override def toString = "Sun" }
case object Sunu46Chromosphere extends EnumRegion { override def toString = "Sun.Chromosphere" }
case object Sunu46Corona extends EnumRegion { override def toString = "Sun.Corona" }
case object Sunu46Interior extends EnumRegion { override def toString = "Sun.Interior" }
case object Sunu46Photosphere extends EnumRegion { override def toString = "Sun.Photosphere" }
case object Sunu46TransitionRegion extends EnumRegion { override def toString = "Sun.TransitionRegion" }
case object Titan extends EnumRegion { override def toString = "Titan" }
case object Uranus extends EnumRegion { override def toString = "Uranus" }
case object Venus extends EnumRegion { override def toString = "Venus" }

trait EnumRenderingAxis

object EnumRenderingAxis {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumRenderingAxis = value match {
    case "ColorBar" => ColorBar
    case "Horizontal" => Horizontal
    case "Vertical" => Vertical

  }
}

case object ColorBar extends EnumRenderingAxis { override def toString = "ColorBar" }
case object Horizontal extends EnumRenderingAxis { override def toString = "Horizontal" }
case object Vertical extends EnumRenderingAxis { override def toString = "Vertical" }

trait EnumRole

object EnumRole {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumRole = value match {
    case "ArchiveSpecialist" => ArchiveSpecialist
    case "CoInvestigator" => CoInvestigator
    case "Contributor" => Contributor
    case "DataProducer" => DataProducer
    case "DeputyPI" => DeputyPI
    case "FormerPI" => FormerPI
    case "GeneralContact" => GeneralContact
    case "MetadataContact" => MetadataContact
    case "PrincipalInvestigator" => PrincipalInvestigator
    case "ProjectScientist" => ProjectScientist
    case "Publisher" => Publisher
    case "Scientist" => Scientist
    case "TeamLeader" => TeamLeader
    case "TeamMember" => TeamMember
    case "TechnicalContact" => TechnicalContact

  }
}

case object ArchiveSpecialist extends EnumRole { override def toString = "ArchiveSpecialist" }
case object CoInvestigator extends EnumRole { override def toString = "CoInvestigator" }
case object Contributor extends EnumRole { override def toString = "Contributor" }
case object DataProducer extends EnumRole { override def toString = "DataProducer" }
case object DeputyPI extends EnumRole { override def toString = "DeputyPI" }
case object FormerPI extends EnumRole { override def toString = "FormerPI" }
case object GeneralContact extends EnumRole { override def toString = "GeneralContact" }
case object MetadataContact extends EnumRole { override def toString = "MetadataContact" }
case object PrincipalInvestigator extends EnumRole { override def toString = "PrincipalInvestigator" }
case object ProjectScientist extends EnumRole { override def toString = "ProjectScientist" }
case object Publisher extends EnumRole { override def toString = "Publisher" }
case object Scientist extends EnumRole { override def toString = "Scientist" }
case object TeamLeader extends EnumRole { override def toString = "TeamLeader" }
case object TeamMember extends EnumRole { override def toString = "TeamMember" }
case object TechnicalContact extends EnumRole { override def toString = "TechnicalContact" }

trait EnumScaleType

object EnumScaleType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumScaleType = value match {
    case "LinearScale" => LinearScale
    case "LogScale" => LogScale

  }
}

case object LinearScale extends EnumScaleType { override def toString = "LinearScale" }
case object LogScale extends EnumScaleType { override def toString = "LogScale" }

trait EnumSourceType

object EnumSourceType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumSourceType = value match {
    case "Ancillary" => Ancillary
    case "Browse" => Browse
    case "Data" => DataValue
    case "Layout" => Layout
    case "Thumbnail" => Thumbnail

  }
}

case object Ancillary extends EnumSourceType { override def toString = "Ancillary" }
case object Browse extends EnumSourceType { override def toString = "Browse" }
case object DataValue extends EnumSourceType { override def toString = "Data" }
case object Layout extends EnumSourceType { override def toString = "Layout" }
case object Thumbnail extends EnumSourceType { override def toString = "Thumbnail" }

trait EnumSpectralRange

object EnumSpectralRange {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumSpectralRange = value match {
    case "CaK" => CaK
    case "ExtremeUltraviolet" => ExtremeUltraviolet
    case "FarUltraviolet" => FarUltraviolet
    case "GammaRays" => GammaRays
    case "Halpha" => Halpha
    case "HardXrays" => HardXrays
    case "He10830" => He10830
    case "He304" => He304
    case "Infrared" => Infrared
    case "K7699" => K7699
    case "LBHBand" => LBHBand
    case "Microwave" => Microwave
    case "NaD" => NaD
    case "Ni6768" => Ni6768
    case "Optical" => Optical
    case "RadioFrequency" => RadioFrequency
    case "SoftXRays" => SoftXRays
    case "Ultraviolet" => Ultraviolet
    case "WhiteLight" => WhiteLight
    case "XRays" => XRays

  }
}

case object CaK extends EnumSpectralRange { override def toString = "CaK" }
case object ExtremeUltraviolet extends EnumSpectralRange { override def toString = "ExtremeUltraviolet" }
case object FarUltraviolet extends EnumSpectralRange { override def toString = "FarUltraviolet" }
case object GammaRays extends EnumSpectralRange { override def toString = "GammaRays" }
case object Halpha extends EnumSpectralRange { override def toString = "Halpha" }
case object HardXrays extends EnumSpectralRange { override def toString = "HardXrays" }
case object He10830 extends EnumSpectralRange { override def toString = "He10830" }
case object He304 extends EnumSpectralRange { override def toString = "He304" }
case object Infrared extends EnumSpectralRange { override def toString = "Infrared" }
case object K7699 extends EnumSpectralRange { override def toString = "K7699" }
case object LBHBand extends EnumSpectralRange { override def toString = "LBHBand" }
case object Microwave extends EnumSpectralRange { override def toString = "Microwave" }
case object NaD extends EnumSpectralRange { override def toString = "NaD" }
case object Ni6768 extends EnumSpectralRange { override def toString = "Ni6768" }
case object Optical extends EnumSpectralRange { override def toString = "Optical" }
case object RadioFrequency extends EnumSpectralRange { override def toString = "RadioFrequency" }
case object SoftXRays extends EnumSpectralRange { override def toString = "SoftXRays" }
case object Ultraviolet extends EnumSpectralRange { override def toString = "Ultraviolet" }
case object WhiteLight extends EnumSpectralRange { override def toString = "WhiteLight" }
case object XRays extends EnumSpectralRange { override def toString = "XRays" }

trait EnumSun

object EnumSun {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumSun = value match {
    case "Chromosphere" => Chromosphere
    case "Corona" => Corona
    case "Interior" => Interior
    case "Photosphere" => Photosphere
    case "TransitionRegion" => TransitionRegion

  }
}

case object Chromosphere extends EnumSun { override def toString = "Chromosphere" }
case object Corona extends EnumSun { override def toString = "Corona" }
case object Interior extends EnumSun { override def toString = "Interior" }
case object Photosphere extends EnumSun { override def toString = "Photosphere" }
case object TransitionRegion extends EnumSun { override def toString = "TransitionRegion" }

trait EnumSupportQuantity

object EnumSupportQuantity {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumSupportQuantity = value match {
    case "InstrumentMode" => InstrumentMode
    case "Other" => OtherValue3
    case "Positional" => Positional
    case "Temporal" => Temporal
    case "Velocity" => VelocityValue

  }
}

case object InstrumentMode extends EnumSupportQuantity { override def toString = "InstrumentMode" }
case object OtherValue3 extends EnumSupportQuantity { override def toString = "Other" }
case object Positional extends EnumSupportQuantity { override def toString = "Positional" }
case object Temporal extends EnumSupportQuantity { override def toString = "Temporal" }
case object VelocityValue extends EnumSupportQuantity { override def toString = "Velocity" }

trait EnumText

object EnumText {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumText = value match {
    case "ASCII" => ASCII
    case "Unicode" => Unicode

  }
}

case object ASCII extends EnumText { override def toString = "ASCII" }
case object Unicode extends EnumText { override def toString = "Unicode" }

trait EnumWaveQuantity

object EnumWaveQuantity {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumWaveQuantity = value match {
    case "ACElectricField" => ACElectricField
    case "ACMagneticField" => ACMagneticField
    case "Absorption" => Absorption
    case "Albedo" => Albedo
    case "DopplerFrequency" => DopplerFrequency
    case "Emissivity" => Emissivity
    case "EnergyFlux" => EnergyFluxValue
    case "EquivalentWidth" => EquivalentWidth
    case "Frequency" => Frequency
    case "Gyrofrequency" => GyrofrequencyValue2
    case "Intensity" => Intensity
    case "LineDepth" => LineDepth
    case "MagneticField" => MagneticFieldValue
    case "ModeAmplitude" => ModeAmplitude
    case "PlasmaFrequency" => PlasmaFrequencyValue2
    case "Polarization" => Polarization
    case "PoyntingFlux" => PoyntingFluxValue
    case "PropagationTime" => PropagationTime
    case "StokesParameters" => StokesParametersValue
    case "Velocity" => VelocityValue2
    case "Wavelength" => Wavelength

  }
}

case object ACElectricField extends EnumWaveQuantity { override def toString = "ACElectricField" }
case object ACMagneticField extends EnumWaveQuantity { override def toString = "ACMagneticField" }
case object Absorption extends EnumWaveQuantity { override def toString = "Absorption" }
case object Albedo extends EnumWaveQuantity { override def toString = "Albedo" }
case object DopplerFrequency extends EnumWaveQuantity { override def toString = "DopplerFrequency" }
case object Emissivity extends EnumWaveQuantity { override def toString = "Emissivity" }
case object EnergyFluxValue extends EnumWaveQuantity { override def toString = "EnergyFlux" }
case object EquivalentWidth extends EnumWaveQuantity { override def toString = "EquivalentWidth" }
case object Frequency extends EnumWaveQuantity { override def toString = "Frequency" }
case object GyrofrequencyValue2 extends EnumWaveQuantity { override def toString = "Gyrofrequency" }
case object Intensity extends EnumWaveQuantity { override def toString = "Intensity" }
case object LineDepth extends EnumWaveQuantity { override def toString = "LineDepth" }
case object MagneticFieldValue extends EnumWaveQuantity { override def toString = "MagneticField" }
case object ModeAmplitude extends EnumWaveQuantity { override def toString = "ModeAmplitude" }
case object PlasmaFrequencyValue2 extends EnumWaveQuantity { override def toString = "PlasmaFrequency" }
case object Polarization extends EnumWaveQuantity { override def toString = "Polarization" }
case object PoyntingFluxValue extends EnumWaveQuantity { override def toString = "PoyntingFlux" }
case object PropagationTime extends EnumWaveQuantity { override def toString = "PropagationTime" }
case object StokesParametersValue extends EnumWaveQuantity { override def toString = "StokesParameters" }
case object VelocityValue2 extends EnumWaveQuantity { override def toString = "Velocity" }
case object Wavelength extends EnumWaveQuantity { override def toString = "Wavelength" }

trait EnumWaveType

object EnumWaveType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumWaveType = value match {
    case "Electromagnetic" => Electromagnetic
    case "Electrostatic" => Electrostatic
    case "Hydrodynamic" => Hydrodynamic
    case "MHD" => MHDValue
    case "Photon" => Photon
    case "PlasmaWaves" => PlasmaWaves

  }
}

case object Electromagnetic extends EnumWaveType { override def toString = "Electromagnetic" }
case object Electrostatic extends EnumWaveType { override def toString = "Electrostatic" }
case object Hydrodynamic extends EnumWaveType { override def toString = "Hydrodynamic" }
case object MHDValue extends EnumWaveType { override def toString = "MHD" }
case object Photon extends EnumWaveType { override def toString = "Photon" }
case object PlasmaWaves extends EnumWaveType { override def toString = "PlasmaWaves" }

trait EnumWaves

object EnumWaves {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumWaves = value match {
    case "Active" => Active
    case "Passive" => Passive

  }
}

case object Active extends EnumWaves { override def toString = "Active" }
case object Passive extends EnumWaves { override def toString = "Passive" }


/** 
               An accessible portion of another resource.
               A Granule may be composed of one or more physical
               pieces (files) which are considered inseparable.
               For example, a data storage format that maintains
               metadata and binary data in separate, but
               tightly coupled files. Granules should not
               be used to group files that have simple relationships
               or which are associated through a parent resource.
               For example, each file containing a time interval
               data for a Numerical Data resource would each
               be considered a Granule. The ParentID of a
               Granule resource must be a NumericalData resource.
               The attributes of a Granule supersede the
               corresponding attributes in the NumericalData
               resource.
            
*/
case class Granule(ResourceID: String,
  ReleaseDate: javax.xml.datatype.XMLGregorianCalendar,
  ExpirationDate: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  ParentID: String,
  PriorID: Seq[String] = Nil,
  granuleoption: scalaxb.DataRecord[Any],
  granuleoption2: Option[scalaxb.DataRecord[Any]] = None,
  Source: Seq[models.binding.Source] = Nil)

trait GranuleOption
trait GranuleOption2

/** 
               Data stored as numerical values in a specified
               format. A Numerical Data resource is a type
               of "data product" which is a set of data that
               is uniformly processed and formatted, from
               one or more instruments, typically spanning
               the full duration of the observations of the
               relevant instrument(s). A data product may
               consist of a collection of granules of successive
               time spans, but may be a single high-level
               entity.
            
*/
case class NumericalOutput(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  AccessInformation: Seq[models.binding.AccessInformation] = Nil,
  ProcessingLevel: Option[models.binding.EnumProcessingLevel] = None,
  ProviderResourceName: Option[String] = None,
  ProviderProcessingLevel: Option[String] = None,
  ProviderVersion: Option[String] = None,
  SimulatedInstrumentID: Seq[String] = Nil,
  MeasurementType: Seq[models.binding.EnumMeasurementType] = Nil,
  numericaloutputoption: Option[scalaxb.DataRecord[models.binding.NumericalOutputOption]] = None,
  SpectralRange: Seq[models.binding.EnumSpectralRange] = Nil,
  SimulatedRegion: Seq[String] = Nil,
  Caveats: Option[String] = None,
  Keyword: Seq[String] = Nil,
  InputResourceID: Seq[String] = Nil,
  Parameter: Seq[models.binding.Parameter] = Nil,
  SimulationProduct: models.binding.EnumProduct,
  Property: Seq[models.binding.Property] = Nil,
  Extension: Option[models.binding.Extension] = None)

trait NumericalOutputOption

/** 
               A graphical representation of data wherein
               the underlying numeric values are not (readily)
               accessible for analysis.. Examples are line
               plots and spectrograms. A Display Data resource
               is a type of "data product" which is a set
               of data that is uniformly processed and formatted,
               from one or more instruments, typically spanning
               the full duration of the observations of the
               relevant instrument(s). A data product may
               consist of a collection of granules of successive
               time spans, but may be a single high-level
               entity.
            
*/
case class DisplayOutput(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  AccessInformation: Seq[models.binding.AccessInformation] = Nil,
  ProcessingLevel: Option[models.binding.EnumProcessingLevel] = None,
  ProviderResourceName: Option[String] = None,
  ProviderProcessingLevel: Option[String] = None,
  ProviderVersion: Option[String] = None,
  SimulatedInstrumentID: Seq[String] = Nil,
  MeasurementType: Seq[models.binding.EnumMeasurementType] = Nil,
  displayoutputoption: Option[scalaxb.DataRecord[models.binding.DisplayOutputOption]] = None,
  SpectralRange: Seq[models.binding.EnumSpectralRange] = Nil,
  DisplayCadence: Option[javax.xml.datatype.Duration] = None,
  SimulatedRegion: Seq[String] = Nil,
  Caveats: Option[String] = None,
  Keyword: Seq[String] = Nil,
  InputResourceID: Seq[String] = Nil,
  Parameter: Seq[models.binding.Parameter] = Nil,
  SimulationProduct: models.binding.EnumProduct,
  Property: Seq[models.binding.Property] = Nil,
  Extension: Option[models.binding.Extension] = None)

trait DisplayOutputOption

/** Descriptor of a simulation model: type of numerical scheme, versions,...
*/
case class SimulationModel(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  Versions: Option[models.binding.Versions] = None,
  SimulationType: models.binding.EnumSimulationType,
  CodeLanguage: Option[String] = None,
  TemporalDependence: Option[models.binding.EnumYN] = None,
  SpatialDescription: Option[models.binding.SpatialDescription] = None,
  SimulatedRegion: Seq[String] = Nil,
  InputProperties: Option[models.binding.InputProperties] = None,
  OutputParameters: Option[models.binding.OutputParameters] = None,
  ModelURL: Option[java.net.URI] = None)


case class InputProperties(Property: models.binding.Property*)


case class OutputParameters(Parameter: models.binding.Parameter*)


/** 
	       Description of a simulation run, including the
	       code ID, the run spatial and temporal description,
	       and all the relevant inputs.
            
*/
case class SimulationRun(ResourceID: String,
  ResourceHeader: models.binding.ResourceHeader,
  AccessInformation: Seq[models.binding.AccessInformation] = Nil,
  ProviderResourceName: Option[String] = None,
  ProviderProcessingLevel: Option[String] = None,
  ProviderVersion: Option[String] = None,
  Model: models.binding.Model,
  TemporalDependence: Option[models.binding.EnumYN] = None,
  SimulatedRegion: Seq[String] = Nil,
  LikelihoodRating: models.binding.EnumConfidenceRating,
  Caveats: Option[String] = None,
  Keyword: Seq[String] = Nil,
  InputResourceID: Seq[String] = Nil,
  SimulationTime: models.binding.SimulationTime,
  SimulationDomain: models.binding.SimulationDomain,
  InputEntity: Seq[scalaxb.DataRecord[Any]] = Nil,
  Extension: Seq[models.binding.Extension] = Nil)


case class Model(ModelID: String,
  VersionID: Option[String] = None)


case class ModelVersion(VersionID: String,
  ReleaseDate: javax.xml.datatype.XMLGregorianCalendar,
  Description: Option[String] = None,
  Caveats: Option[String] = None)


case class Versions(ModelVersion: models.binding.ModelVersion*)


case class RegionParameter(SimulatedRegion: String,
  Description: Option[String] = None,
  Caveats: Option[String] = None,
  Radius: Option[models.binding.InputValue] = None,
  SubLongitude: Option[models.binding.InputValue] = None,
  Period: Option[models.binding.InputValue] = None,
  ObjectMass: Option[models.binding.InputValue] = None,
  InputTableURL: Option[java.net.URI] = None,
  Property: Seq[models.binding.Property] = Nil)


/** 
               A container of information regarding an input
	       parameter of the simulation run. The parameter
	       may contain many properties.
            
*/
case class InputParameter(Name: String,
  Description: Option[String] = None,
  Caveats: Option[String] = None,
  SimulatedRegion: Seq[String] = Nil,
  Qualifier: Seq[models.binding.EnumQualifier] = Nil,
  ParameterQuantity: String,
  InputTableURL: Option[java.net.URI] = None,
  Property: Seq[models.binding.Property] = Nil)


/** 
               A container of information regarding a property
	       of an input parameter.
            
*/
case class Property(Name: Option[String] = None,
  Description: Option[String] = None,
  Caveats: Option[String] = None,
  PropertyQuantity: String,
  Qualifier: Seq[models.binding.EnumQualifier] = Nil,
  Units: Option[String] = None,
  UnitsConversion: Option[String] = None,
  PropertyLabel: Option[Seq[String]] = None,
  PropertyValue: Option[Seq[String]] = None,
  PropertyTableURL: Option[java.net.URI] = None,
  ValidMin: Option[String] = None,
  ValidMax: Option[String] = None,
  PropertyModel: Option[String] = None,
  ModelURL: Option[java.net.URI] = None)


/** 
               Parameters associated to a simulated specie
            
*/
case class InputPopulation(inputpopulationsequence1: models.binding.InputPopulationSequence1,
  inputpopulationsequence2: models.binding.InputPopulationSequence2,
  inputpopulationsequence3: models.binding.InputPopulationSequence3) {
  lazy val Name = inputpopulationsequence1.Name
  lazy val Set = inputpopulationsequence1.Set
  lazy val ParameterKey = inputpopulationsequence1.ParameterKey
  lazy val Description = inputpopulationsequence1.Description
  lazy val Caveats = inputpopulationsequence1.Caveats
  lazy val SimulatedRegion = inputpopulationsequence1.SimulatedRegion
  lazy val Qualifier = inputpopulationsequence1.Qualifier
  lazy val ParticleType = inputpopulationsequence1.ParticleType
  lazy val ChemicalFormula = inputpopulationsequence1.ChemicalFormula
  lazy val AtomicNumber = inputpopulationsequence1.AtomicNumber
  lazy val PopulationMassNumber = inputpopulationsequence2.PopulationMassNumber
  lazy val PopulationChargeState = inputpopulationsequence2.PopulationChargeState
  lazy val PopulationDensity = inputpopulationsequence2.PopulationDensity
  lazy val PopulationTemperature = inputpopulationsequence2.PopulationTemperature
  lazy val PopulationFlowSpeed = inputpopulationsequence2.PopulationFlowSpeed
  lazy val Distribution = inputpopulationsequence2.Distribution
  lazy val ProductionRate = inputpopulationsequence2.ProductionRate
  lazy val TotalProductionRate = inputpopulationsequence2.TotalProductionRate
  lazy val InputTableURL = inputpopulationsequence2.InputTableURL
  lazy val Profile = inputpopulationsequence2.Profile
  lazy val ModelURL = inputpopulationsequence3.ModelURL
}


case class InputPopulationSequence3(ModelURL: Option[java.net.URI] = None)
case class InputPopulationSequence2(PopulationMassNumber: Option[Double] = None,
  PopulationChargeState: Option[Double] = None,
  PopulationDensity: Option[models.binding.InputValue] = None,
  PopulationTemperature: Option[models.binding.InputValue] = None,
  PopulationFlowSpeed: Option[models.binding.InputValue] = None,
  Distribution: Option[String] = None,
  ProductionRate: Option[models.binding.InputValue] = None,
  TotalProductionRate: Option[models.binding.InputValue] = None,
  InputTableURL: Option[java.net.URI] = None,
  Profile: Option[String] = None)

case class InputPopulationSequence1(Name: String,
  Set: Seq[String] = Nil,
  ParameterKey: Option[String] = None,
  Description: Option[String] = None,
  Caveats: Option[String] = None,
  SimulatedRegion: Seq[String] = Nil,
  Qualifier: Seq[models.binding.EnumQualifier] = Nil,
  ParticleType: models.binding.EnumParticleType,
  ChemicalFormula: Option[String] = None,
  AtomicNumber: Option[Double] = None)


/** 
               Parameters associated to a field imposed in the simulation
            
*/
case class InputField(Name: String,
  Set: Seq[String] = Nil,
  ParameterKey: Option[String] = None,
  Description: Option[String] = None,
  Caveats: Option[String] = None,
  SimulatedRegion: Seq[String] = Nil,
  CoordinateSystem: Option[models.binding.CoordinateSystemType] = None,
  Qualifier: Seq[models.binding.EnumQualifier] = Nil,
  FieldQuantity: models.binding.EnumFieldQuantity,
  Units: Option[String] = None,
  UnitsConversion: Option[String] = None,
  InputLabel: Option[Seq[String]] = None,
  FieldValue: Option[Seq[String]] = None,
  InputTableURL: Option[java.net.URI] = None,
  ValidMin: Option[String] = None,
  ValidMax: Option[String] = None,
  FieldModel: Option[String] = None,
  ModelURL: Option[java.net.URI] = None)


/** 
               Parameters associated to a chemical process happening in the simulation
            
*/
case class InputProcess(Name: String,
  Set: Seq[String] = Nil,
  ParameterKey: Option[String] = None,
  Description: Option[String] = None,
  Caveats: Option[String] = None,
  SimulatedRegion: Seq[String] = Nil,
  ProcessType: models.binding.EnumProcessType,
  Units: Option[String] = None,
  UnitsConversion: Option[String] = None,
  ProcessCoefficient: Option[String] = None,
  ProcessCoeffType: Option[models.binding.EnumProcCoefType] = None,
  ProcessModel: Option[String] = None,
  ModelURL: Option[java.net.URI] = None)


/** 
               Parameters associated to the simulation spatial domain.
            
*/
case class SimulationDomain(CoordinateSystem: models.binding.CoordinateSystemType,
  Description: Option[String] = None,
  Caveats: Option[String] = None,
  SpatialDimension: BigInt,
  VelocityDimension: Option[BigInt] = None,
  FieldDimension: Option[BigInt] = None,
  Units: String,
  UnitsConversion: Option[String] = None,
  CoordinatesLabel: Option[Seq[String]] = None,
  ValidMin: Option[String] = None,
  ValidMax: Option[String] = None,
  GridStructure: Option[String] = None,
  GridCellSize: Option[Seq[Float]] = None,
  Symmetry: Option[models.binding.EnumSymmetry] = None,
  BoundaryConditions: Option[models.binding.BoundaryConditions] = None)


/** 
               Parameters associated to the simulation boundaries.
            
*/
case class BoundaryConditions(ParticleBoundary: Option[models.binding.ElementBoundary] = None,
  FieldBoundary: Option[models.binding.ElementBoundary] = None)


/** 
               Parameters associated to the simulation time.
            
*/
case class SimulationTime(Description: Option[String] = None,
  Caveats: Option[String] = None,
  Duration: Option[javax.xml.datatype.Duration] = None,
  TimeStart: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  TimeStop: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  TimeStep: Option[javax.xml.datatype.Duration] = None,
  DiagnosisTimeStep: Option[models.binding.DiagnosisTimeStep] = None)


/** 
               Time at which a diagnosis is performed and quantity saved.
            
*/
case class DiagnosisTimeStep(SavedQuantity: Seq[String] = Nil,
  TimeStart: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  Duration: Option[javax.xml.datatype.Duration] = None)


/** 
               Parameters associated to the simulation Boundaries.
            
*/
case class ElementBoundary(Caveats: Option[String] = None,
  FrontWall: Option[String] = None,
  BackWall: Option[String] = None,
  SideWall: Option[String] = None,
  Obstacle: Option[String] = None)


/** 
               A characterization of the spatial extent over which
               the measurement was taken.
            
*/
case class SpatialDescription(Dimension: BigInt,
  CoordinateSystem: models.binding.CoordinateSystemType,
  Units: String,
  UnitsConversion: Option[String] = None,
  CoordinatesLabel: Option[Seq[String]] = None,
  spatialdescriptionoption: scalaxb.DataRecord[Any],
  Step: Option[String] = None) extends NumericalOutputOption with DisplayOutputOption

trait SpatialDescriptionOption
trait EnumProcessType

object EnumProcessType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumProcessType = value match {
    case "ChargeExchange" => ChargeExchange
    case "ElectronImpact" => ElectronImpact
    case "PhotoIonization" => PhotoIonization
    case "DissociativeRecombination" => DissociativeRecombination

  }
}

case object ChargeExchange extends EnumProcessType { override def toString = "ChargeExchange" }
case object ElectronImpact extends EnumProcessType { override def toString = "ElectronImpact" }
case object PhotoIonization extends EnumProcessType { override def toString = "PhotoIonization" }
case object DissociativeRecombination extends EnumProcessType { override def toString = "DissociativeRecombination" }

trait EnumProcCoefType

object EnumProcCoefType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumProcCoefType = value match {
    case "CrossSection" => CrossSection
    case "Frequency" => FrequencyValue
    case "Rate" => Rate
    case "Other" => OtherValue4

  }
}

case object CrossSection extends EnumProcCoefType { override def toString = "CrossSection" }
case object FrequencyValue extends EnumProcCoefType { override def toString = "Frequency" }
case object Rate extends EnumProcCoefType { override def toString = "Rate" }
case object OtherValue4 extends EnumProcCoefType { override def toString = "Other" }

trait EnumSymmetry

object EnumSymmetry {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumSymmetry = value match {
    case "None" => NoneTypeValue
    case "Axial" => Axial
    case "Plane" => Plane
    case "Central" => Central

  }
}

case object NoneTypeValue extends EnumSymmetry { override def toString = "None" }
case object Axial extends EnumSymmetry { override def toString = "Axial" }
case object Plane extends EnumSymmetry { override def toString = "Plane" }
case object Central extends EnumSymmetry { override def toString = "Central" }

trait EnumYN

object EnumYN {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumYN = value match {
    case "Yes" => YesValue
    case "No" => NoValue

  }
}

case object YesValue extends EnumYN { override def toString = "Yes" }
case object NoValue extends EnumYN { override def toString = "No" }

trait EnumSimulationType

object EnumSimulationType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumSimulationType = value match {
    case "Analytic" => Analytic
    case "Hybrid" => Hybrid
    case "MHD" => MHD
    case "PIC" => PIC
    case "Test_Particle" => Test_Particle
    case "Paraboloid" => Paraboloid

  }
}

case object Analytic extends EnumSimulationType { override def toString = "Analytic" }
case object Hybrid extends EnumSimulationType { override def toString = "Hybrid" }
case object MHD extends EnumSimulationType { override def toString = "MHD" }
case object PIC extends EnumSimulationType { override def toString = "PIC" }
case object Test_Particle extends EnumSimulationType { override def toString = "Test_Particle" }
case object Paraboloid extends EnumSimulationType { override def toString = "Paraboloid" }

trait EnumProduct

object EnumProduct {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumProduct = value match {
    case "3DCubes" => Number3DCubes
    case "2DCuts" => Number2DCuts
    case "TimeSeries" => TimeSeriesValue
    case "SpatialSeries" => SpatialSeries
    case "Lines" => Lines
    case "Spectra" => Spectra

  }
}

case object Number3DCubes extends EnumProduct { override def toString = "3DCubes" }
case object Number2DCuts extends EnumProduct { override def toString = "2DCuts" }
case object TimeSeriesValue extends EnumProduct { override def toString = "TimeSeries" }
case object SpatialSeries extends EnumProduct { override def toString = "SpatialSeries" }
case object Lines extends EnumProduct { override def toString = "Lines" }
case object Spectra extends EnumProduct { override def toString = "Spectra" }

trait EnumImpexQuantity

object EnumImpexQuantity {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EnumImpexQuantity = value match {
    case "SolarUVFlux" => SolarUVFlux
    case "IMFClockAngle" => IMFClockAngle

  }
}

case object SolarUVFlux extends EnumImpexQuantity { override def toString = "SolarUVFlux" }
case object IMFClockAngle extends EnumImpexQuantity { override def toString = "IMFClockAngle" }


/** 
               A description of the types of particles observed
               in the measurement. This includes both direct
               observations and inferred observations.
            
*/
case class Particle(PopulationID: Option[String] = None,
  ParticleType: Seq[models.binding.EnumParticleType] = Nil,
  Qualifier: Seq[models.binding.EnumQualifier] = Nil,
  ParticleQuantity: models.binding.EnumParticleQuantity,
  ChemicalFormula: Option[String] = None,
  AtomicNumber: Seq[Double] = Nil,
  PopulationMassNumber: Seq[Double] = Nil,
  PopulationChargeState: Seq[Double] = Nil,
  EnergyRange: Option[models.binding.EnergyRange] = None,
  AzimuthalAngleRange: Option[models.binding.AzimuthalAngleRange] = None,
  PolarAngleRange: Option[models.binding.PolarAngleRange] = None)


case class InputValue(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  Units: Option[String] = None,
  UnitsConversion: Option[String] = None)

case class CubesDescriptionSequence(RegionBegin: Seq[Float],
  RegionEnd: Seq[Float])

case class CutsDescriptionSequence(PlaneNormalVector: Seq[Float],
  PlanePoint: Seq[Float])

