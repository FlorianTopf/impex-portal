// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package models.binding

import play.api.libs.json._
import java.net.URI
import scalaxb.DataRecord
import play.api.libs.functional.syntax._


/** 
    VOTable1.2 is meant to serialize tabular documents in the
    context of Virtual Observatory applications. This schema
    corresponds to the VOTable document available from
    http://www.ivoa.net/Documents/latest/VOT.html

*/


case class AnyTEXT(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)

trait EncodingType

object EncodingType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EncodingType = value match {
    case "gzip" => Gzip
    case "base64" => Base64
    case "dynamic" => Dynamic
    case "none" => NoneType

  }
}

case object Gzip extends EncodingType { override def toString = "gzip" }
case object Base64 extends EncodingType { override def toString = "base64" }
case object Dynamic extends EncodingType { override def toString = "dynamic" }
case object NoneType extends EncodingType { override def toString = "none" }

trait DataType

object DataType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): DataType = value match {
    case "boolean" => BooleanType
    case "bit" => Bit
    case "unsignedByte" => UnsignedByte
    case "short" => ShortType
    case "int" => IntType
    case "long" => LongType
    case "char" => CharType
    case "unicodeChar" => UnicodeChar
    case "float" => FloatType
    case "double" => DoubleType
    case "floatComplex" => FloatComplex
    case "doubleComplex" => DoubleComplex

  }
}

case object BooleanType extends DataType { override def toString = "boolean" }
case object Bit extends DataType { override def toString = "bit" }
case object UnsignedByte extends DataType { override def toString = "unsignedByte" }
case object ShortType extends DataType { override def toString = "short" }
case object IntType extends DataType { override def toString = "int" }
case object LongType extends DataType { override def toString = "long" }
case object CharType extends DataType { override def toString = "char" }
case object UnicodeChar extends DataType { override def toString = "unicodeChar" }
case object FloatType extends DataType { override def toString = "float" }
case object DoubleType extends DataType { override def toString = "double" }
case object FloatComplex extends DataType { override def toString = "floatComplex" }
case object DoubleComplex extends DataType { override def toString = "doubleComplex" }

trait Yesno

object Yesno {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Yesno = value match {
    case "yes" => Yes
    case "no" => No

  }
}

case object Yes extends Yesno { override def toString = "yes" }
case object No extends Yesno { override def toString = "no" }


case class Min(valueAttribute: String,
  inclusive: models.binding.Yesno)


case class Max(valueAttribute: String,
  inclusive: models.binding.Yesno)


case class OptionType(OPTION: Seq[models.binding.OptionType] = Nil,
  name: Option[String] = None,
  valueAttribute: String)

trait Type

object Type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Type = value match {
    case "legal" => Legal
    case "actual" => Actual

  }
}

case object Legal extends Type { override def toString = "legal" }
case object Actual extends Type { override def toString = "actual" }


case class Values(MIN: Option[models.binding.Min] = None,
  MAX: Option[models.binding.Max] = None,
  OPTION: Seq[models.binding.OptionType] = Nil,
  ID: Option[String] = None,
  typeValue: models.binding.Type,
  nullValue: Option[String] = None,
  ref: Option[String] = None)


/**  
    content-role was previsouly restricted as: 
    <xs:attribute name="content-role">
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="query"/>
          <xs:enumeration value="hints"/>
          <xs:enumeration value="doc"/>
          <xs:enumeration value="location"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>; is now a name token.
    
*/
case class Link(ID: Option[String] = None,
  contentu45role: Option[String] = None,
  contentu45type: Option[String] = None,
  title: Option[String] = None,
  valueAttribute: Option[String] = None,
  href: Option[java.net.URI] = None,
  gref: Option[String] = None,
  action: Option[java.net.URI] = None)


case class Info(value: String,
  ID: Option[String] = None,
  name: String,
  valueAttribute: String,
  unit: Option[String] = None,
  xtype: Option[String] = None,
  ref: Option[String] = None,
  ucd: Option[String] = None,
  utype: Option[String] = None) extends VOTABLEOption

trait System

object System {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): System = value match {
    case "eq_FK4" => Eq_FK4
    case "eq_FK5" => Eq_FK5
    case "ICRS" => ICRS
    case "ecl_FK4" => Ecl_FK4
    case "ecl_FK5" => Ecl_FK5
    case "galactic" => Galactic
    case "supergalactic" => Supergalactic
    case "xy" => Xy
    case "barycentric" => Barycentric
    case "geo_app" => Geo_app

  }
}

case object Eq_FK4 extends System { override def toString = "eq_FK4" }
case object Eq_FK5 extends System { override def toString = "eq_FK5" }
case object ICRS extends System { override def toString = "ICRS" }
case object Ecl_FK4 extends System { override def toString = "ecl_FK4" }
case object Ecl_FK5 extends System { override def toString = "ecl_FK5" }
case object Galactic extends System { override def toString = "galactic" }
case object Supergalactic extends System { override def toString = "supergalactic" }
case object Xy extends System { override def toString = "xy" }
case object Barycentric extends System { override def toString = "barycentric" }
case object Geo_app extends System { override def toString = "geo_app" }


/** 
    Deprecated in Version 1.2
  
*/
case class CoordinateSystem(value: String,
  ID: String,
  equinox: Option[String] = None,
  epoch: Option[String] = None,
  system: models.binding.System) extends DefinitionsOption with ResourceOption with VOTABLEOption


/** 
    Deprecated in Version 1.1
  
*/
case class Definitions(definitionsoption: scalaxb.DataRecord[models.binding.DefinitionsOption]*)

trait DefinitionsOption
trait TypeType

object TypeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType = value match {
    case "hidden" => Hidden
    case "no_query" => No_query
    case "trigger" => Trigger
    case "location" => LocationValue

  }
}

case object Hidden extends TypeType { override def toString = "hidden" }
case object No_query extends TypeType { override def toString = "no_query" }
case object Trigger extends TypeType { override def toString = "trigger" }
case object LocationValue extends TypeType { override def toString = "location" }


trait Fieldable extends TableOption {
  val DESCRIPTION: Option[models.binding.AnyTEXT]
  val VALUES: Option[models.binding.Values]
  val LINK: Seq[models.binding.Link]
  val ID: Option[String]
  val unit: Option[String]
  val datatype: models.binding.DataType
  val precision: Option[String]
  val width: Option[BigInt]
  val xtype: Option[String]
  val ref: Option[String]
  val name: String
  val ucd: Option[String]
  val utype: Option[String]
  val arraysize: Option[String]
  val typeValue: Option[models.binding.TypeType]
}


case class Field(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  VALUES: Option[models.binding.Values] = None,
  LINK: Seq[models.binding.Link] = Nil,
  ID: Option[String] = None,
  unit: Option[String] = None,
  datatype: models.binding.DataType,
  precision: Option[String] = None,
  width: Option[BigInt] = None,
  xtype: Option[String] = None,
  ref: Option[String] = None,
  name: String,
  ucd: Option[String] = None,
  utype: Option[String] = None,
  arraysize: Option[String] = None,
  typeValue: Option[models.binding.TypeType] = None) extends Fieldable


case class Param(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  VALUES: Option[models.binding.Values] = None,
  LINK: Seq[models.binding.Link] = Nil,
  ID: Option[String] = None,
  unit: Option[String] = None,
  datatype: models.binding.DataType,
  precision: Option[String] = None,
  width: Option[BigInt] = None,
  xtype: Option[String] = None,
  ref: Option[String] = None,
  name: String,
  ucd: Option[String] = None,
  utype: Option[String] = None,
  arraysize: Option[String] = None,
  typeValue: Option[models.binding.TypeType] = None,
  valueAttribute: String) extends Fieldable with DefinitionsOption with GroupOption with TableOption with ResourceOption with VOTABLEOption


case class Group(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  groupoption: Seq[scalaxb.DataRecord[models.binding.GroupOption]] = Nil,
  ID: Option[String] = None,
  name: Option[String] = None,
  ref: Option[String] = None,
  ucd: Option[String] = None,
  utype: Option[String] = None) extends GroupOption with TableOption with ResourceOption with VOTABLEOption

trait GroupOption

case class FieldRef(ref: String,
  ucd: Option[String] = None,
  utype: Option[String] = None) extends GroupOption


case class ParamRef(ref: String,
  ucd: Option[String] = None,
  utype: Option[String] = None) extends GroupOption


/** 
    Added in Version 1.2: INFO for diagnostics
  
*/
case class Data(dataoption: scalaxb.DataRecord[models.binding.DataOption],
  INFO: Seq[models.binding.Info] = Nil)

trait DataOption

case class TableData(TR: models.binding.Tr*) extends DataOption


case class Td(value: String,
  encoding: Option[models.binding.EncodingType] = None)


/** 
    The ID attribute is added here to the TR tag to avoid 
    problems of code generators which do not properly 
    interpret the TR/TD structures
  
*/
case class Tr(TD: Seq[models.binding.Td] = Nil,
  ID: Option[String] = None)


case class FITS(STREAM: models.binding.StreamType,
  extnum: Option[BigInt] = None) extends DataOption


case class Binary(STREAM: models.binding.StreamType) extends DataOption

trait TypeType2

object TypeType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType2 = value match {
    case "locator" => Locator
    case "other" => OtherValue5

  }
}

case object Locator extends TypeType2 { override def toString = "locator" }
case object OtherValue5 extends TypeType2 { override def toString = "other" }

trait Actuate

object Actuate {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Actuate = value match {
    case "onLoad" => OnLoad
    case "onRequest" => OnRequest
    case "other" => OtherValue6
    case "none" => NoneTypeValue3

  }
}

case object OnLoad extends Actuate { override def toString = "onLoad" }
case object OnRequest extends Actuate { override def toString = "onRequest" }
case object OtherValue6 extends Actuate { override def toString = "other" }
case object NoneTypeValue3 extends Actuate { override def toString = "none" }


case class StreamType(value: String,
  typeValue: models.binding.TypeType2,
  href: Option[java.net.URI] = None,
  actuate: models.binding.Actuate,
  encoding: models.binding.EncodingType,
  expires: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  rights: Option[String] = None)


/** 
    Added in Version 1.2: INFO for diagnostics
  
*/
case class Table(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  INFO: Seq[models.binding.Info] = Nil,
  tableoption: Seq[scalaxb.DataRecord[models.binding.TableOption]] = Nil,
  LINK: Seq[models.binding.Link] = Nil,
  DATA: Option[models.binding.Data] = None,
  // @FIXME weird Table definition in xsd (see also xmlprotocol)
  /*INFO: Seq[models.binding.Info] = Nil, */
  ID: Option[String] = None,
  name: Option[String] = None,
  ref: Option[String] = None,
  ucd: Option[String] = None,
  utype: Option[String] = None,
  nrows: Option[BigInt] = None) extends ResourceOption2

trait TableOption
trait TypeType3

object TypeType3 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType3 = value match {
    case "results" => Results
    case "meta" => Meta

  }
}

case object Results extends TypeType3 { override def toString = "results" }
case object Meta extends TypeType3 { override def toString = "meta" }


/** 
     Added in Version 1.2: INFO for diagnostics in several places
  
*/
case class Resource(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  INFO: Seq[models.binding.Info] = Nil,
  resourceoption: Seq[scalaxb.DataRecord[models.binding.ResourceOption]] = Nil,
  resourcesequence1: Seq[models.binding.ResourceSequence1] = Nil,
  any: Seq[scalaxb.DataRecord[Any]] = Nil,
  name: Option[String] = None,
  ID: Option[String] = None,
  utype: Option[String] = None,
  typeValue: models.binding.TypeType3,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends ResourceOption2

case class ResourceSequence1(LINK: Seq[models.binding.Link] = Nil,
  resourceoption2: scalaxb.DataRecord[models.binding.ResourceOption2],
  INFO: Seq[models.binding.Info] = Nil)

trait ResourceOption2
trait ResourceOption
trait Version

object Version {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Version = value match {
    case "1.2" => Number1u462

  }
}

case object Number1u462 extends Version { override def toString = "1.2" }


case class VOTABLE(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  DEFINITIONS: Option[models.binding.Definitions] = None,
  votableoption: Seq[scalaxb.DataRecord[models.binding.VOTABLEOption]] = Nil,
  RESOURCE: Seq[models.binding.Resource] = Nil,
  INFO: Seq[models.binding.Info] = Nil,
  ID: Option[String] = None,
  version: Option[models.binding.Version] = None)

trait VOTABLEOption


// additions for JSON conversion 
// @TODO update all Reads/Writes to play 2.2.x Specifications (if possible)
// see: http://www.playframework.com/documentation/2.2.x/ScalaJsonCombinators
object VOTABLE { 
  
  implicit val votableWrites: Format[VOTABLE] = new Format[VOTABLE] {
    def writes(v: VOTABLE): JsValue = { 
      Json.obj("VOTABLE" -> Json.obj(
        "DESCRIPTION" -> v.DESCRIPTION,
        "INFO" -> v.INFO,
	    "ID" -> v.ID,
	    "version" -> v.version,
        // DEFINITIONS not used in VOTable v1.2
	    //"DEFINITIONS" -> v.DEFINITIONS,
        // votableoption not used in IMPEx
	    //"votableoption" -> v.votableoption,
        "RESOURCE" -> v.RESOURCE))
    }
    
    def reads(json: JsValue): JsResult[VOTABLE] = {
      val votable = (json \ "VOTABLE")
      JsSuccess(VOTABLE(
          (votable \ "DESCRIPTION").asOpt[AnyTEXT],
          None,
          Nil,
          (votable \ "RESOURCE").as[Seq[Resource]],
          (votable \ "INFO").as[Seq[Info]],
          (votable \ "ID").asOpt[String],
          (votable \ "version").asOpt[Version]))
    }
  } 
  
  
  implicit val anyTextFormat: Format[AnyTEXT] = new Format[AnyTEXT] {
    def writes(a: AnyTEXT): JsValue = {
      if(!a.mixed.isEmpty)
        JsString(a.mixed.map(_.as[String]).mkString(" "))
	  else
	    JsNull
	}
    
    def reads(json: JsValue): JsResult[AnyTEXT] = {
      json match {
        case JsNull => JsSuccess(AnyTEXT(Nil))
        case js: JsString => JsSuccess(AnyTEXT(Seq(DataRecord(None, None, json.as[String]))))
        case other => JsError("AnyTEXT unkown")
      }
    }
  }
  
	  
  implicit val resourceWrites: Format[Resource] = new Format[Resource] {
	def writes(r: Resource): JsValue = { 
	  val resources = r.resourcesequence1 map { c => 
	  	   c.resourceoption2.key match {
	  	     // @TODO let's see if TABLE only is sufficient
	  	     case Some("TABLE") => Some(c.resourceoption2.as[Table])
	  	     case _ => None
	  	   }
	  }
	  Json.obj(
	    "DESCRIPTION" -> r.DESCRIPTION,
	    "INFO" -> r.INFO,
	    "name" -> r.name,
	    "ID" -> r.ID,
	    "utype" -> r.utype,
	    "type" -> r.typeValue)++
	    // attributes not used in IMPEx
	    //"attributes" -> r.attributes)++
	    // resourceoption not used in IMPEx
	    //++Json.obj("resourceoption" -> r.resourceoption)
	    // any is also not used in IMPEx
	    Json.obj("TABLE" -> resources)
	}
	
	def reads(json: JsValue): JsResult[Resource] = {
	  val table = (json \ "TABLE").as[Seq[Table]]
	  JsSuccess(Resource(
      (json \ "DESCRIPTION").asOpt[AnyTEXT],
      (json \ "INFO").as[Seq[Info]],
      Nil,
      table.map(t => ResourceSequence1(Nil, DataRecord(None, Some("TABLE"), t))),
      Nil,
      (json \ "name").asOpt[String],
      (json \ "ID").asOpt[String],
      (json \ "utype").asOpt[String],
      (json \ "type").as[TypeType3],
      Map()))
	}
  }
            

  implicit val infoFormat: Format[Info] = Json.format[Info]
  
	  
  implicit val versionFormat: Format[Version] = new Format[Version] {
    def writes(v: Version): JsValue = JsString(v.toString)
	    
	def reads(json: JsValue): JsResult[Version] = {
      json match {
        case json: JsString => {
          try {
            JsSuccess(Version.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	      } catch {
	        case e: Exception => JsError("Invalid Version")
	      }
	    }
	    case other => JsError("Malformed Version")
	  }
	}
  }
  
  
  implicit val typeType3Format: Format[TypeType3] = new Format[TypeType3] {
    def writes(t: TypeType3): JsValue = JsString(t.toString)
	    
	def reads(json: JsValue): JsResult[TypeType3] = {
      json match {
        case json: JsString => {
          try {
            JsSuccess(TypeType3.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	      } catch {
	        case e: Exception => JsError("Invalid TypeType3")
	      }
	    }
	    case other => JsError("Malformed TypType3")
	  }
	}
  }
  
  
  implicit val tableformat: Format[Table] = new Format[Table] {
    def writes(t: Table) = {
      val headers = t.tableoption map { o =>
        o.key match {
          // @TODO let's see if FIELD/PARAM only is sufficient
          // GROUP and FIELDABLE is also possible
          case Some("FIELD") => (o.key.get -> Json.toJson(o.as[Field]))
          case Some("PARAM") => (o.key.get -> Json.toJson(o.as[Param]))
          // should never happen in IMPEx
          case _ => (o.key.get -> JsString("Table option unkown"))
        }
      }
      Json.obj("DESCRIPTION" -> t.DESCRIPTION,
          "INFO" -> t.INFO,
          "LINK" -> t.LINK,
          "ID" -> t.ID,
          "name" -> t.name,
          // ref not used in IMPEx
          //"ref" -> t.ref,
          "ucd" -> t.ucd,
          "utype" -> t.utype
          // nrows not used in IMPEx
          //"nrows" -> t.nrows
          )++Json.obj("FIELD" -> headers.filter(p => p._1 == "FIELD").map(_._2))++
          Json.obj("PARAM" -> headers.filter(p => p._1 == "PARAM").map(_._2))++
          Json.obj("DATA" -> t.DATA)
    }
    
    def reads(json: JsValue): JsResult[Table] = {
      val fields = (json \ "FIELD").as[Seq[Field]]
      val params = (json \ "PARAM").as[Seq[Param]]
      val headers: Seq[DataRecord[TableOption]] = 
        fields.map(f => DataRecord(None, Some("FIELD"), f))++
        params.map(p => DataRecord(None, Some("PARAM"), p))
      JsSuccess(Table(
          (json \ "DESCRIPTION").asOpt[AnyTEXT],
          (json \ "INFO").as[Seq[Info]],
          headers,
          (json \ "LINK").as[Seq[Link]],
          (json \ "DATA").asOpt[Data],
          (json \ "ID").asOpt[String],
          (json \ "name").asOpt[String],
          None,
          (json \ "ucd").asOpt[String],
          (json \ "utype").asOpt[String],
          None))
    }
  }
  
  
  implicit val linkFormat: Format[Link] = Json.format[Link]
  
  
  implicit val urlFormat: Format[URI] = new Format[URI] {
    def writes(u: URI): JsValue = JsString(u.toString)
     
	def reads(j: JsValue): JsResult[URI] = JsSuccess(new URI(j.as[String]))
  }
  
  
  implicit val bigIntFormat: Format[BigInt] = new Format[BigInt] {
    def writes(i: BigInt): JsValue = JsString(i.toString)
    
    def reads(json: JsValue): JsResult[BigInt] = JsSuccess(BigInt(json.as[String]))
  }
  
  
  implicit val fieldFormat: Format[Field] = new Format[Field] {
    def writes(f: Field) = Json.obj(
        "DESCRIPTION" -> f.DESCRIPTION,
        "VALUES" -> f.VALUES,
        "LINK" -> f.LINK,
        "ID" -> f.ID,
        "unit" -> f.unit,
        "datatype" -> f.datatype,
        // precision not used in IMPEx
        //"precision" -> f.precision,
        // width not used in IMPEx
        //"width" -> f.width,
        "xtype" -> f.xtype,
        // ref not used in IMPEx
        //"ref" -> r.ref,
        "name" -> f.name,
        "ucd" -> f.ucd,
        "utype" -> f.utype,
        "arraysize" -> f.arraysize,
        "type" -> f.typeValue)
        
    def reads(json: JsValue): JsResult[Field] = JsSuccess(Field(
        (json \ "DESCRIPTION").asOpt[AnyTEXT],
        (json \ "VALUES").asOpt[Values],
        (json \ "LINK").as[Seq[Link]],
        (json \ "ID").asOpt[String],
        (json \ "unit").asOpt[String],
        (json \ "datatype").as[DataType],
        None,
        None,
        (json \ "xtype").asOpt[String],
        None, 
        (json \ "name").as[String],
        (json \ "ucd").asOpt[String],
        (json \ "utype").asOpt[String],
        (json \ "arraysize").asOpt[String],
        (json \ "type").asOpt[TypeType]))
  }
  
  implicit val valuesFormat: Format[Values] = new Format[Values] {
    def writes(v: Values) = { 
      Json.obj(
          "MIN" -> v.MIN,
          "MAX" -> v.MAX,
          // @FIXME this value is weird in the parser classes
          //"OPTION" -> v.OPTION,
          "ID" -> v.ID,
          "type" -> v.typeValue,
          "null" -> v.nullValue)
          // ref not used in IMPEx
          //"ref" -> v.ref
     }
    
    def reads(json: JsValue): JsResult[Values] = {
      json match {
        case json: JsObject => JsSuccess(Values(
          (json \ "MIN").asOpt[Min],
          (json \ "MAX").asOpt[Max],
          Nil,
          (json \ "ID").asOpt[String],
          (json \ "type").as[Type],
          (json \ "null").asOpt[String]))
        case other => JsError("No Values")   
      }
    }
  }
  
  
  implicit val minFormat: Format[Min] = new Format[Min] {
    def writes(m: Min) = {
      Json.obj("valueAttribute" -> m.valueAttribute,
          "inclusive" -> m.inclusive)
    }

    def reads(json: JsValue): JsResult[Min] = {
      JsSuccess(Min(
          (json \ "valueAttribute").as[String],
    	  (json \ "inclusive").as[Yesno]))
    }
  }
  
  
  implicit val maxFormat: Format[Max] = new Format[Max] {
    def writes(m: Max) = { 
      Json.obj("valueAttribute" -> m.valueAttribute,
          "inclusive" -> m.inclusive)
    }
        
    def reads(json: JsValue): JsResult[Max] = { 
      JsSuccess(Max(
          (json \ "valueAttribute").as[String],
    	  (json \ "inclusive").as[Yesno]))
    }
  }
  
  
  implicit val inclusiveFormat: Format[Yesno] = new Format[Yesno] {
    def writes(yn: Yesno): JsValue = JsString(yn.toString)
	    
	def reads(json: JsValue): JsResult[Yesno] = {
      json match {
        case json: JsString => {
          try {
            JsSuccess(Yesno.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	      } catch {
	        case e: Exception => JsError("Invalid Inclusive")
	      }
	    }
	    case other => JsError("Malformed Inclusive")
	  }
	}
  }
  
	 
  implicit val typeFormat: Format[Type] = new Format[Type] {
    def writes(t: Type): JsValue = JsString(t.toString)
	    
	def reads(json: JsValue): JsResult[Type] = {
      json match {
        case json: JsString => {
          try {
            JsSuccess(Type.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	        } catch {
	          case e: Exception => JsError("Invalid Type")
	        }
	      }
	      case other => JsError("Malformed Type")
	  }
	}
  }
  
  
  implicit val dataTypeFormat: Format[DataType] = new Format[DataType] {
    def writes(t: DataType): JsValue = JsString(t.toString)
	    
	def reads(json: JsValue): JsResult[DataType] = {
      json match {
        case json: JsString => {
          try {
            JsSuccess(DataType.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	        } catch {
	          case e: Exception => JsError("Invalid DataType")
	        }
	      }
	      case other => JsError("Malformed DataType")
	  }
	}
  }
  
  
  implicit val typeTypeFormat: Format[TypeType] = new Format[TypeType] {
    def writes(t: TypeType): JsValue = JsString(t.toString)
	    
	def reads(json: JsValue): JsResult[TypeType] = {
      json match {
        case json: JsString => {
          try {
            JsSuccess(TypeType.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	        } catch {
	          case e: Exception => JsError("Invalid TypeType")
	        }
	      }
	      case other => JsError("Malformed TypeType")
	  }
	}
  }
  
  
  implicit val dataFormat: Format[Data] = new Format[Data] {
    def writes(d: Data): JsValue = {
      val data = d.dataoption.key match {
        // @TODO let's see if TABLEDATA only is sufficient
        // RESOURCE is also possible
        case Some("TABLEDATA")  => Json.obj("TABLEDATA" -> d.dataoption.as[TableData])
        case _ => Json.obj()  
      }
      Json.obj("INFO" -> d.INFO)++data
    }
    
    def reads(json: JsValue): JsResult[Data] = JsSuccess(Data(
        DataRecord(None, Some("TABLEDATA"), (json \ "TABLEDATA").as[TableData]), 
        Nil))
  }
  
  
  implicit val tableDataFormat: Format[TableData] = new Format[TableData] {
    def writes(t: TableData): JsValue = { 
      JsArray(t.TR.map(tr => Json.obj("TR" -> tr)))
    }
    
    def reads(json: JsValue): JsResult[TableData] = {
      JsSuccess(TableData((json \\ "TR").map(_.as[Tr]):_*))
    }
  }
  
  
  implicit val trFormat: Format[Tr] = new Format[Tr] {
    def writes(tr: Tr): JsValue = { 
      Json.obj("ID" -> tr.ID, "TD" -> tr.TD)
    }
    
    def reads(json: JsValue): JsResult[Tr] = {
      JsSuccess(Tr((json \ "TD").as[Seq[Td]], (json \ "ID").as[Option[String]]))
    }
  }
  
  
  implicit val tdFormat: Format[Td] = new Format[Td] {
    def writes(td: Td): JsValue = { 
      Json.obj("value" -> td.value)
      // @TODO seems to be not needed
      // , "encoding" -> td.encoding)
    }
    
    def reads(json: JsValue): JsResult[Td] = { 
      JsSuccess(Td((json \ "value").as[String]))
    }
  }
  
	  
  implicit val encodingTypeFormat: Format[EncodingType] = new Format[EncodingType] {
    def writes(t: EncodingType): JsValue = JsString(t.toString)
	    
	def reads(json: JsValue): JsResult[EncodingType] = {
      json match {
        case json: JsString => {
          try {
            JsSuccess(EncodingType.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	        } catch {
	          case e: Exception => JsError("Invalid EncodingType")
	        }
	      }
	      case other => JsError("Malformed EncodingType")
	  }
	}
  }
  
  
  implicit val paramFormat: Format[Param] = new Format[Param] {
    def writes(p: Param): JsValue = Json.obj(
        "DESCRIPTION" -> p.DESCRIPTION,
        "VALUES" -> p.VALUES,
        "LINK" -> p.LINK,
        "ID" -> p.ID,
        "unit" -> p.unit,
        "datatype" -> p.datatype,
        // precision is not used in IMPEx
        //"precision" -> p.precision,
        // width is not used in IMPEx
        //"width" -> p.width,
        "xtype" -> p.xtype,
        // ref is not used in IMPEx
        //"ref" -> p.ref,
        "name" -> p.name,
        "ucd" -> p.ucd,
        "utype" -> p.utype,
        "arraysize" -> p.arraysize,
        "typeValue" -> p.typeValue,
        "valueAttribute" -> p.valueAttribute)
        
    def reads(json: JsValue): JsResult[Param] = JsSuccess(Param(
        (json \ "DESCRIPTION").asOpt[AnyTEXT],
        (json \ "VALUES").asOpt[Values],
        (json \ "LINK").as[Seq[Link]],
        (json \ "ID").asOpt[String],
        (json \ "unit").asOpt[String],
        (json \ "datatype").as[DataType],
        None,
        None,
        (json \ "xtype").asOpt[String],
        None,
        (json \ "name").as[String],
        (json \ "ucd").asOpt[String],
        (json \ "utype").asOpt[String],
        (json \ "arraysize").asOpt[String],
        (json \ "typeValue").asOpt[TypeType],
        (json \ "valueAttribute").as[String]))
  } 
  
  
}
