// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package models.binding

import play.api.libs.json._
import java.net.URI


/** 
    VOTable1.2 is meant to serialize tabular documents in the
    context of Virtual Observatory applications. This schema
    corresponds to the VOTable document available from
    http://www.ivoa.net/Documents/latest/VOT.html

*/


case class AnyTEXT(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)

trait EncodingType

object EncodingType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EncodingType = value match {
    case "gzip" => Gzip
    case "base64" => Base64
    case "dynamic" => Dynamic
    case "none" => NoneType

  }
}

case object Gzip extends EncodingType { override def toString = "gzip" }
case object Base64 extends EncodingType { override def toString = "base64" }
case object Dynamic extends EncodingType { override def toString = "dynamic" }
case object NoneType extends EncodingType { override def toString = "none" }

trait DataType

object DataType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): DataType = value match {
    case "boolean" => BooleanType
    case "bit" => Bit
    case "unsignedByte" => UnsignedByte
    case "short" => ShortType
    case "int" => IntType
    case "long" => LongType
    case "char" => CharType
    case "unicodeChar" => UnicodeChar
    case "float" => FloatType
    case "double" => DoubleType
    case "floatComplex" => FloatComplex
    case "doubleComplex" => DoubleComplex

  }
}

case object BooleanType extends DataType { override def toString = "boolean" }
case object Bit extends DataType { override def toString = "bit" }
case object UnsignedByte extends DataType { override def toString = "unsignedByte" }
case object ShortType extends DataType { override def toString = "short" }
case object IntType extends DataType { override def toString = "int" }
case object LongType extends DataType { override def toString = "long" }
case object CharType extends DataType { override def toString = "char" }
case object UnicodeChar extends DataType { override def toString = "unicodeChar" }
case object FloatType extends DataType { override def toString = "float" }
case object DoubleType extends DataType { override def toString = "double" }
case object FloatComplex extends DataType { override def toString = "floatComplex" }
case object DoubleComplex extends DataType { override def toString = "doubleComplex" }

trait Yesno

object Yesno {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Yesno = value match {
    case "yes" => Yes
    case "no" => No

  }
}

case object Yes extends Yesno { override def toString = "yes" }
case object No extends Yesno { override def toString = "no" }


case class Min(valueAttribute: String,
  inclusive: models.binding.Yesno)


case class Max(valueAttribute: String,
  inclusive: models.binding.Yesno)


case class OptionType(OPTION: Seq[models.binding.OptionType] = Nil,
  name: Option[String] = None,
  valueAttribute: String)

trait Type

object Type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Type = value match {
    case "legal" => Legal
    case "actual" => Actual

  }
}

case object Legal extends Type { override def toString = "legal" }
case object Actual extends Type { override def toString = "actual" }


case class Values(MIN: Option[models.binding.Min] = None,
  MAX: Option[models.binding.Max] = None,
  OPTION: Seq[models.binding.OptionType] = Nil,
  ID: Option[String] = None,
  typeValue: models.binding.Type,
  nullValue: Option[String] = None,
  ref: Option[String] = None)


/**  
    content-role was previsouly restricted as: 
    <xs:attribute name="content-role">
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="query"/>
          <xs:enumeration value="hints"/>
          <xs:enumeration value="doc"/>
          <xs:enumeration value="location"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>; is now a name token.
    
*/
case class Link(ID: Option[String] = None,
  contentu45role: Option[String] = None,
  contentu45type: Option[String] = None,
  title: Option[String] = None,
  valueAttribute: Option[String] = None,
  href: Option[java.net.URI] = None,
  gref: Option[String] = None,
  action: Option[java.net.URI] = None)


case class Info(value: String,
  ID: Option[String] = None,
  name: String,
  valueAttribute: String,
  unit: Option[String] = None,
  xtype: Option[String] = None,
  ref: Option[String] = None,
  ucd: Option[String] = None,
  utype: Option[String] = None) extends VOTABLEOption

trait System

object System {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): System = value match {
    case "eq_FK4" => Eq_FK4
    case "eq_FK5" => Eq_FK5
    case "ICRS" => ICRS
    case "ecl_FK4" => Ecl_FK4
    case "ecl_FK5" => Ecl_FK5
    case "galactic" => Galactic
    case "supergalactic" => Supergalactic
    case "xy" => Xy
    case "barycentric" => Barycentric
    case "geo_app" => Geo_app

  }
}

case object Eq_FK4 extends System { override def toString = "eq_FK4" }
case object Eq_FK5 extends System { override def toString = "eq_FK5" }
case object ICRS extends System { override def toString = "ICRS" }
case object Ecl_FK4 extends System { override def toString = "ecl_FK4" }
case object Ecl_FK5 extends System { override def toString = "ecl_FK5" }
case object Galactic extends System { override def toString = "galactic" }
case object Supergalactic extends System { override def toString = "supergalactic" }
case object Xy extends System { override def toString = "xy" }
case object Barycentric extends System { override def toString = "barycentric" }
case object Geo_app extends System { override def toString = "geo_app" }


/** 
    Deprecated in Version 1.2
  
*/
case class CoordinateSystem(value: String,
  ID: String,
  equinox: Option[String] = None,
  epoch: Option[String] = None,
  system: models.binding.System) extends DefinitionsOption with ResourceOption with VOTABLEOption


/** 
    Deprecated in Version 1.1
  
*/
case class Definitions(definitionsoption: scalaxb.DataRecord[models.binding.DefinitionsOption]*)

trait DefinitionsOption
trait TypeType

object TypeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType = value match {
    case "hidden" => Hidden
    case "no_query" => No_query
    case "trigger" => Trigger
    case "location" => LocationValue

  }
}

case object Hidden extends TypeType { override def toString = "hidden" }
case object No_query extends TypeType { override def toString = "no_query" }
case object Trigger extends TypeType { override def toString = "trigger" }
case object LocationValue extends TypeType { override def toString = "location" }


trait Fieldable extends TableOption {
  val DESCRIPTION: Option[models.binding.AnyTEXT]
  val VALUES: Option[models.binding.Values]
  val LINK: Seq[models.binding.Link]
  val ID: Option[String]
  val unit: Option[String]
  val datatype: models.binding.DataType
  val precision: Option[String]
  val width: Option[BigInt]
  val xtype: Option[String]
  val ref: Option[String]
  val name: String
  val ucd: Option[String]
  val utype: Option[String]
  val arraysize: Option[String]
  val typeValue: Option[models.binding.TypeType]
}


case class Field(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  VALUES: Option[models.binding.Values] = None,
  LINK: Seq[models.binding.Link] = Nil,
  ID: Option[String] = None,
  unit: Option[String] = None,
  datatype: models.binding.DataType,
  precision: Option[String] = None,
  width: Option[BigInt] = None,
  xtype: Option[String] = None,
  ref: Option[String] = None,
  name: String,
  ucd: Option[String] = None,
  utype: Option[String] = None,
  arraysize: Option[String] = None,
  typeValue: Option[models.binding.TypeType] = None) extends Fieldable


case class Param(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  VALUES: Option[models.binding.Values] = None,
  LINK: Seq[models.binding.Link] = Nil,
  ID: Option[String] = None,
  unit: Option[String] = None,
  datatype: models.binding.DataType,
  precision: Option[String] = None,
  width: Option[BigInt] = None,
  xtype: Option[String] = None,
  ref: Option[String] = None,
  name: String,
  ucd: Option[String] = None,
  utype: Option[String] = None,
  arraysize: Option[String] = None,
  typeValue: Option[models.binding.TypeType] = None,
  valueAttribute: String) extends Fieldable with DefinitionsOption with GroupOption with TableOption with ResourceOption with VOTABLEOption


case class Group(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  groupoption: Seq[scalaxb.DataRecord[models.binding.GroupOption]] = Nil,
  ID: Option[String] = None,
  name: Option[String] = None,
  ref: Option[String] = None,
  ucd: Option[String] = None,
  utype: Option[String] = None) extends GroupOption with TableOption with ResourceOption with VOTABLEOption

trait GroupOption

case class FieldRef(ref: String,
  ucd: Option[String] = None,
  utype: Option[String] = None) extends GroupOption


case class ParamRef(ref: String,
  ucd: Option[String] = None,
  utype: Option[String] = None) extends GroupOption


/** 
    Added in Version 1.2: INFO for diagnostics
  
*/
case class Data(dataoption: scalaxb.DataRecord[models.binding.DataOption],
  INFO: Seq[models.binding.Info] = Nil)

trait DataOption

case class TableData(TR: models.binding.Tr*) extends DataOption


case class Td(value: String,
  encoding: Option[models.binding.EncodingType] = None)


/** 
    The ID attribute is added here to the TR tag to avoid 
    problems of code generators which do not properly 
    interpret the TR/TD structures
  
*/
case class Tr(TD: Seq[models.binding.Td] = Nil,
  ID: Option[String] = None)


case class FITS(STREAM: models.binding.StreamType,
  extnum: Option[BigInt] = None) extends DataOption


case class Binary(STREAM: models.binding.StreamType) extends DataOption

trait TypeType2

object TypeType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType2 = value match {
    case "locator" => Locator
    case "other" => OtherValue5

  }
}

case object Locator extends TypeType2 { override def toString = "locator" }
case object OtherValue5 extends TypeType2 { override def toString = "other" }

trait Actuate

object Actuate {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Actuate = value match {
    case "onLoad" => OnLoad
    case "onRequest" => OnRequest
    case "other" => OtherValue6
    case "none" => NoneTypeValue3

  }
}

case object OnLoad extends Actuate { override def toString = "onLoad" }
case object OnRequest extends Actuate { override def toString = "onRequest" }
case object OtherValue6 extends Actuate { override def toString = "other" }
case object NoneTypeValue3 extends Actuate { override def toString = "none" }


case class StreamType(value: String,
  typeValue: models.binding.TypeType2,
  href: Option[java.net.URI] = None,
  actuate: models.binding.Actuate,
  encoding: models.binding.EncodingType,
  expires: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  rights: Option[String] = None)


/** 
    Added in Version 1.2: INFO for diagnostics
  
*/
case class Table(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  INFO: Seq[models.binding.Info] = Nil,
  tableoption: Seq[scalaxb.DataRecord[models.binding.TableOption]] = Nil,
  LINK: Seq[models.binding.Link] = Nil,
  DATA: Option[models.binding.Data] = None,
  // @FIXME weird Table definition in xsd (see also xmlprotocol)
  /*INFO: Seq[models.binding.Info] = Nil, */
  ID: Option[String] = None,
  name: Option[String] = None,
  ref: Option[String] = None,
  ucd: Option[String] = None,
  utype: Option[String] = None,
  nrows: Option[BigInt] = None) extends ResourceOption2

trait TableOption
trait TypeType3

object TypeType3 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType3 = value match {
    case "results" => Results
    case "meta" => Meta

  }
}

case object Results extends TypeType3 { override def toString = "results" }
case object Meta extends TypeType3 { override def toString = "meta" }


/** 
     Added in Version 1.2: INFO for diagnostics in several places
  
*/
case class Resource(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  INFO: Seq[models.binding.Info] = Nil,
  resourceoption: Seq[scalaxb.DataRecord[models.binding.ResourceOption]] = Nil,
  resourcesequence1: Seq[models.binding.ResourceSequence1] = Nil,
  any: Seq[scalaxb.DataRecord[Any]] = Nil,
  name: Option[String] = None,
  ID: Option[String] = None,
  utype: Option[String] = None,
  typeValue: models.binding.TypeType3,
  attributes: Map[String, scalaxb.DataRecord[Any]]) extends ResourceOption2

case class ResourceSequence1(LINK: Seq[models.binding.Link] = Nil,
  resourceoption2: scalaxb.DataRecord[models.binding.ResourceOption2],
  INFO: Seq[models.binding.Info] = Nil)

trait ResourceOption2
trait ResourceOption
trait Version

object Version {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Version = value match {
    case "1.2" => Number1u462

  }
}

case object Number1u462 extends Version { override def toString = "1.2" }


case class VOTABLE(DESCRIPTION: Option[models.binding.AnyTEXT] = None,
  DEFINITIONS: Option[models.binding.Definitions] = None,
  votableoption: Seq[scalaxb.DataRecord[models.binding.VOTABLEOption]] = Nil,
  RESOURCE: Seq[models.binding.Resource] = Nil,
  INFO: Seq[models.binding.Info] = Nil,
  ID: Option[String] = None,
  version: Option[models.binding.Version] = None)

trait VOTABLEOption


// additions for JSON conversion (@TODO full two way conversion)
object VOTABLE { 
	  
  implicit val votableFormat: Writes[VOTABLE] = new Writes[VOTABLE] {
    def writes(v: VOTABLE): JsValue = Json.obj("VOTABLE" -> Json.obj(
        "DESCRIPTION" -> v.DESCRIPTION,
        "INFO" -> v.INFO,
	    "ID" -> v.ID,
	    "version" -> v.version,
	    // left out (not used in VOTable v1.2)
	    //"DEFINITIONS" -> v.DEFINITIONS,
	    // left out (@FIXME not used in IMPEx?)
	    //"votableoption" -> v.votableoption.toString,
	    // main resource container
        "RESOURCE" -> v.RESOURCE
	    ))
	}
  
  implicit val anyTextFormat: Writes[Option[AnyTEXT]] = new Writes[Option[AnyTEXT]] {
    def writes(a: Option[AnyTEXT]): JsValue = a match {
	  case Some(a) if(!a.mixed.isEmpty) => JsString(a.mixed.map(_.as[String]).mkString(" "))
	  case _ => JsString("")
	}
  }
	  
  implicit val resourceFormat: Writes[Resource] = new Writes[Resource] {
	def writes(r: Resource): JsValue = { 
	  val resources = r.resourcesequence1 map { c => 
	  	   c.resourceoption2.key match {
	  	     // @TODO let's see if TABLE only is sufficient
	  	     case Some("TABLE") => Json.toJson(c.resourceoption2.as[Table])
	  	     case _ => JsString("RESOURCE OPTION UNKNOWN")
	  	   }
	  }
	  
	  Json.obj(
	    "DESCRIPTION" -> r.DESCRIPTION,
	    "INFO" -> r.INFO,
	    "name" -> r.name,
	    "ID" -> r.ID,
	    "utype" -> r.utype,
	    "type" -> r.typeValue)++
	    //"attributed -> r.attributes)
	    // left out (not used in IMPEx?)
	    //++Json.obj("resourceoption" -> r.resourceoption.toString)
	    Json.obj("TABLE" -> resources)

	}
  }

  implicit val infoFormat: Format[Info] = Json.format[Info]
	  
  implicit val versionFormat: Format[Version] = new Format[Version] {
    def writes(v: Version): JsValue = JsString(v.toString)
	    
	def reads(json: JsValue): JsResult[Version] = {
      json match {
        case jsString: JsString => {
          try {
            JsSuccess(Version.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	      } catch {
	        case e: Exception => JsError("Invalid Version")
	      }
	    }
	    case other => JsError("Malformed Version")
	  }
	}
  }
  
  implicit val typeType3Format: Format[TypeType3] = new Format[TypeType3] {
    def writes(t: TypeType3): JsValue = JsString(t.toString)
	    
	def reads(json: JsValue): JsResult[TypeType3] = {
      json match {
        case jsString: JsString => {
          try {
            JsSuccess(TypeType3.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	      } catch {
	        case e: Exception => JsError("Invalid TypeType3")
	      }
	    }
	    case other => JsError("Malformed TypType3")
	  }
	}
  }
  
  implicit val tableformat: Writes[Table] = new Writes[Table] {
    def writes(t: Table) = {
      val tableHeaders = t.tableoption map { o =>
        o.key match {
          // @TODO let's see if FIELD/PARAM only is sufficient
          // GROUP and FIELDABLE possible
          case Some("FIELD") => (o.key.get -> Json.toJson(o.as[Field]))
          case Some("PARAM") => (o.key.get -> Json.toJson(o.as[Param]))
          case _ => ("ERROR for"+o.key.get -> JsString("TABLE OPTION UNKNOWN"))
        }
      }
      
      Json.obj("DESCRIPTION" -> t.DESCRIPTION,
          "INFO" -> t.INFO,
          "LINK" -> t.LINK)++
          Json.obj("FIELD" -> tableHeaders.filter(p => p._1 == "FIELD").map(_._2))++
          Json.obj("PARAM" -> tableHeaders.filter(p => p._1 == "PARAM").map(_._2))++
      Json.obj("DATA" -> t.DATA, // the real data
          "ID" -> t.ID,
          "name" -> t.name,
          //"ref" -> t.ref,
          "ucd" -> t.ucd,
          "utype" -> t.utype
          //"nrows" -> t.nrows
          )
    }
  }
  
  implicit val linkFormat: Format[Link] = Json.format[Link]
  
   implicit val urlFormat: Format[URI] = new Format[URI] {
     def writes(u: URI): JsValue = JsString(u.toString)
	 def reads(j: JsValue): JsResult[URI] = JsSuccess(new URI(j.as[String]))
   }
  
  // @FIXME maybe not optimal => why can't we use JsNumber()?
  implicit val bigIntWrites: Writes[BigInt] = new Writes[BigInt] {
    def writes(i: BigInt): JsValue = JsString(i.toString)
  }
  
  implicit val fieldFormat: Writes[Field] = new Writes[Field] {
    def writes(f: Field) = Json.obj(
        "DESCRIPTION" -> f.DESCRIPTION,
        "VALUES" -> f.VALUES,
        "LINK" -> f.LINK,
        "ID" -> f.ID,
        "unit" -> f.unit,
        "datatype" -> f.datatype,
        //"precision" -> f.precision,
        //"width" -> f.width,
        "xtype" -> f.xtype,
        //"ref" -> r.ref,
        "name" -> f.name,
        "ucd" -> f.ucd,
        "utype" -> f.utype,
        "arraysize" -> f.arraysize,
        "typeValue" -> f.typeValue)
  }
  
  implicit val valuesFormat: Writes[Values] = new Writes[Values] {
    def writes(v: Values) = Json.obj(
        "MIN" -> v.MIN,
        "MAX" -> v.MAX,
        // @FIXME this value is weird in the parser classes
        //"OPTION" -> v.OPTION,
        "ID" -> v.ID,
        "typeValue" -> v.typeValue,
        "nullValue" -> v.nullValue
        //"ref" -> v.ref
    ) 
  }
  
  implicit val minFormat: Writes[Min] = new Writes[Min] {
    def writes(m: Min) = Json.obj("valueAttribute" -> m.valueAttribute,
        "inclusive" -> m.inclusive)
    
  }
  
  implicit val maxFormat: Writes[Max] = new Writes[Max] {
    def writes(m: Max) = Json.obj("valueAttribute" -> m.valueAttribute,
        "inclusive" -> m.inclusive)
  }
  
  implicit val inclusiveFormat: Format[Yesno] = new Format[Yesno] {
    def writes(yn: Yesno): JsValue = JsString(yn.toString)
	    
	def reads(json: JsValue): JsResult[Yesno] = {
      json match {
        case jsString: JsString => {
          try {
            JsSuccess(Yesno.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	      } catch {
	        case e: Exception => JsError("Invalid Inclusive")
	      }
	    }
	    case other => JsError("Malformed Inclusive")
	  }
	}
  }
	 
  implicit val typeFormat: Format[Type] = new Format[Type] {
    def writes(t: Type): JsValue = JsString(t.toString)
	    
	def reads(json: JsValue): JsResult[Type] = {
      json match {
        case jsString: JsString => {
          try {
            JsSuccess(Type.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	        } catch {
	          case e: Exception => JsError("Invalid Type")
	        }
	      }
	      case other => JsError("Malformed Type")
	  }
	}
  }
  
  implicit val dataTypeFormat: Format[DataType] = new Format[DataType] {
    def writes(t: DataType): JsValue = JsString(t.toString)
	    
	def reads(json: JsValue): JsResult[DataType] = {
      json match {
        case jsString: JsString => {
          try {
            JsSuccess(DataType.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	        } catch {
	          case e: Exception => JsError("Invalid DataType")
	        }
	      }
	      case other => JsError("Malformed DataType")
	  }
	}
  }
  
  implicit val typeTypeFormat: Format[TypeType] = new Format[TypeType] {
    def writes(t: TypeType): JsValue = JsString(t.toString)
	    
	def reads(json: JsValue): JsResult[TypeType] = {
      json match {
        case jsString: JsString => {
          try {
            JsSuccess(TypeType.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	        } catch {
	          case e: Exception => JsError("Invalid TypeType")
	        }
	      }
	      case other => JsError("Malformed TypeType")
	  }
	}
  }
  
  implicit val dataFormat: Writes[Data] = new Writes[Data] {
    def writes(d: Data): JsValue = {
      val data = d.dataoption.key match {
        // @TODO let's see if TABLEDATA only is sufficient
        // RESOURCE possible
        case Some("TABLEDATA")  => Json.obj("TABLEDATA" -> d.dataoption.as[TableData])
        case _ => Json.obj("ERROR" -> "TABLE OPTION UNKNOWN")  
      }
      Json.obj("INFO" -> d.INFO)++data
    }
  }
  
  implicit val tableDataFormat: Writes[TableData] = new Writes[TableData] {
    def writes(t: TableData): JsValue = Json.obj("TR" -> t.TR)
  }
  
  implicit val trFormat: Writes[Tr] = new Writes[Tr] {
    def writes(tr: Tr): JsValue = Json.obj("TD" -> tr.TD, "ID" -> tr.ID)
  }
  
  implicit val tdFormat: Writes[Td] = new Writes[Td] {
    def writes(td: Td): JsValue = Json.obj("value" -> td.value)
    // @TODO seems to be not needed
    // , "encoding" -> td.encoding)
  }
	  
  implicit val encodingTypeFormat: Format[EncodingType] = new Format[EncodingType] {
    def writes(t: EncodingType): JsValue = JsString(t.toString)
	    
	def reads(json: JsValue): JsResult[EncodingType] = {
      json match {
        case jsString: JsString => {
          try {
            JsSuccess(EncodingType.fromString(json.as[String],
                scalaxb.toScope(None -> "http://www.ivoa.net/xml/VOTable/v1.2")))
	        } catch {
	          case e: Exception => JsError("Invalid EncodingType")
	        }
	      }
	      case other => JsError("Malformed EncodingType")
	  }
	}
  }
  
  implicit val paramFormat: Writes[Param] = new Writes[Param] {
    def writes(p: Param) = Json.obj(
        "DESCRIPTION" -> p.DESCRIPTION,
        "VALUES" -> p.VALUES,
        "LINK" -> p.LINK,
        "ID" -> p.ID,
        "unit" -> p.unit,
        "datatype" -> p.datatype,
        //"precision" -> p.precision,
        //"width" -> p.width,
        "xtype" -> p.xtype,
        //"ref" -> p.ref,
        "name" -> p.name,
        "ucd" -> p.ucd,
        "utype" -> p.utype,
        "arraysize" -> p.arraysize,
        "typeValue" -> p.typeValue,
        "valuAttribute" -> p.valueAttribute)
  } 
  
  
  
}
